[{"categories":["算法","面试"],"content":"读题，易知： 若 t 是 s 的子序列，则 m（s 的长度）大于等于 n（t 的长度），即当 m 小于 n 时直接返回 0。 在 m 大于等于 n 的条件下，用 dp[i][j] 来表示 s[i:] 的子序列中 t[j:] 的个数。 首先考虑边界情况： 当 j = n 时，t[j:] 为空串，由于空串是任何字符串的子串，因此，对任意$0 \\le i \\le m$ ","date":"2021-03-17","objectID":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/:0:0","tags":["动态规划"],"title":"力扣每日一题 115 不同的子序列","uri":"/posts/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98-115-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/"},{"categories":[],"content":"Windows 添加环境变量 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"CMD 操作 # SET PATH=C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA\\v11.0\\bin;%PATH% SET PATH=your_folder_path;%PATH% ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:1","tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"窗口操作 打开我的电脑，右键点击左侧的此电脑，点击属性。 点击最下方的高级系统设置，然后点击环境变量。 修改系统变量：下方选择需要修改的变量，点击编辑，然后新建或者编辑变量。 新建系统变量：直接点击新建，输入变量名和变量值，然后确定。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:2","tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"VS Code ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"C++ 编译器（二选一） 安装 Visual Studio 安装 MinGW-w64，SourceForge VS Code ms-cpp-tools # Linux gcc -v -E -x c++ - 参考 关闭 Windows Defender “首次看到时阻止”： 问题描述： 编译运行程序的时候总是弹出一个 Microsoft Defender 防病毒程序窗口，提示“需要扫描当前程序”。 解决方法： 按Win+R，输入gpedit.msc，打开本地组策略编辑器。 左侧选择计算机配置-\u003e管理模板-\u003eWindows 组件-Microsoft Defender 防病毒-\u003eMAPS。 右侧双击配置“首次看到时阻止”功能，选择已禁用，然后点击确定，保存退出。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:1","tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"Anaconda # 更新 Anaconda，C:\\ProgramData\\Anaconda3 为安装目录 conda update --prefix C:\\ProgramData\\Anaconda3 anaconda # 创建环境 conda create -n ENVNAME python=3.X # 启用环境 conda activate ENVNAME # 退出环境 conda deactivate # 删除环境 conda remove -n ENVNAME --all -y # 查看环境列表 conda info -e # 或者 conda env list # 设置 proxy_server conda config --set proxy_servers.http http://127.0.0.1:10809 conda config --set proxy_servers.https http://127.0.0.1:10809 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"PyTorch https://pytorch.org/get-started/locally/ CPU： conda install pytorch torchvision torchaudio cpuonly -c pytorch pip install torch==1.8.0+cpu torchvision==0.9.0+cpu torchaudio===0.8.0 -f https://download.pytorch.org/whl/torch_stable.html GPU： conda install pytorch torchvision torchaudio cudatoolkit=11.1 -c pytorch -c conda-forge pip install torch==1.8.0+cu111 torchvision==0.9.0+cu111 torchaudio===0.8.0 -f https://download.pytorch.org/whl/torch_stable.html 检查是否安装成功： import torch # 检查 pytorch 是否安装成功 print(torch.__version__) # 检查 CUDA 是否可用 print(torch.cuda.is_available()) ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"TensorFlow https://tensorflow.google.cn/install 安装时下载： pip install tensorflow # for CPU and GPU 下载后安装： # https://storage.googleapis.com/tensorflow/windows/cpu/tensorflow_cpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_cpu-2.4.1-cp38-cp38-win_amd64.whl # CPU # https://storage.googleapis.com/tensorflow/windows/gpu/tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl pip install tensorflow_gpu-2.4.0-cp38-cp38-win_amd64.whl # GPU ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:5:0","tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"CUDA \u0026 cuDNN 以笔记本 RTX2060 显卡为例 NVIDIA 驱动程序下载，选择对应版本，下载安装。 CUDA 工具包下载，下载最新版安装。 在CMD输入nvcc -V，出现如下输出表示安装成功。 nvcc: NVIDIA (R) Cuda compiler driver Copyright (c) 2005-2020 NVIDIA Corporation Built on Tue_Sep_15_19:12:04_Pacific_Daylight_Time_2020 Cuda compilation tools, release 11.1, V11.1.74 Build cuda_11.1.relgpu_drvr455TC455_06.29069683_0 cuDNN 下载，需要登陆账号，登陆后下载解压将bin、include和lib三个文件夹的内容复制到 CUDA 安装目录下。 ","date":"2021-03-15","objectID":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:6:0","tags":[],"title":"环境搭建","uri":"/posts/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":[],"content":"Git is the open source distributed version control system. ","date":"2021-03-11","objectID":"/posts/git-tutorials/:0:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Install Git Download Git for Windows, MacOS and Linux. ","date":"2021-03-11","objectID":"/posts/git-tutorials/:1:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Configure Tooling Configure user information for all local repositories. # Sets the name you want attached to your commit transactions git config --global user.name \"USERNAME\" # Sets the email you want attached to your commit transactions git config --global user.email \"USERNAME@email.com\" ","date":"2021-03-11","objectID":"/posts/git-tutorials/:2:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Create Repositories Start a new repository or obtain one from an existing URL. # Creates a new local repository with the specified name git init [PROJECT-NAME] # Downloads a project and its entire version history git clone https://github.com/username/repo-name.git ","date":"2021-03-11","objectID":"/posts/git-tutorials/:3:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Make Changes Review edits and craft a commit transaction. # Lists all new or modified files to be commited git status # Shows file differences not yet staged git diff # Snapshots the file in preparation for versioning git add FILENAME # Shows file differences between staging and the last file version git diff --staged # Unstages the file, but preserve its contents git reset FILENAME # Records file snapshots permanently in version history git commit -m \"DESCRIPTIONS\" ","date":"2021-03-11","objectID":"/posts/git-tutorials/:4:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Group Changes Name a series of commits and combine completed efforts. # Lists all local branches in the current repository git branch # Creates a new branch git branch BRANCH-NAME # Switches to the specified branch and updates the working directory git checkout BRANCH-NAME # Combines the specified branch’s history into the current branch git merge BRANCH-NAME # Deletes the specified branch git branch -d BRANCH-NAME ","date":"2021-03-11","objectID":"/posts/git-tutorials/:5:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Refactor Filenames Relocate and remove versioned files. # Deletes the file from the working directory and stages the deletion git rm FILENAME # Removes the file from version control but preserves the file locally git rm --cached FILENAME # Changes the file name and prepares it for commit git mv OLD-FILENAME NEW-FILENAME ","date":"2021-03-11","objectID":"/posts/git-tutorials/:6:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Suppress Tracking Exclude temporary files and paths. A text file named .gitignore suppresses accidental versioning of files and paths matching the specified patterns. *.log build/ temp-* # Lists all ignored files in this project git ls-files --other --ignored --exclude-standard ","date":"2021-03-11","objectID":"/posts/git-tutorials/:7:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Save Fragments Shelve and restore incomplete changes. # Temporarily stores all modified tracked files git stash # Restores the most recently stashed files git stash pop # Lists all stashed changesets git stash list # Discards the most recently stashed changeset git stash drop ","date":"2021-03-11","objectID":"/posts/git-tutorials/:8:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Review History Browse and inspect the evolution of project files. # Lists version history for the current branch git log # Lists version history for a file, including renames git log --follow FILENAME # Shows content differences between two branches git diff BRANCH-1-NAME BRANCH-2-NAME # Outputs metadata and content changes of the specified commit git show COMMIT-ID ","date":"2021-03-11","objectID":"/posts/git-tutorials/:9:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Redo Commits Erase mistakes and craft replacement history. # Undoes all commits after COMMIT-ID, preserving changes locally git reset COMMIT-ID # Discards all history and changes back to the specified commit git reset --hard COMMIT-ID ","date":"2021-03-11","objectID":"/posts/git-tutorials/:10:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"Synchronize Changes Register a repository bookmark and exchange version history. # Downloads all history from the repository bookmark git fetch BOOKMARK # Combines bookmark’s branch into current local branch git merge BOOKMARK/BRANCH-NAME # Uploads all local branch commits to GitHub git push ALIAS BRANCH-NAME # Downloads bookmark history and incorporates changes git pull ","date":"2021-03-11","objectID":"/posts/git-tutorials/:11:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"References Git Cheat Sheets ","date":"2021-03-11","objectID":"/posts/git-tutorials/:12:0","tags":[],"title":"Git Tutorials","uri":"/posts/git-tutorials/"},{"categories":[],"content":"饥荒 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:0:0","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"食谱 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:0","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"肉丸 肉度×0.5，1肉3填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 62.5 5 3 15秒 10天 食材1 食材2 食材3 食材4 怪物肉、大肉、小肉、鸡腿 浆果、冰 浆果、冰 浆果、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:1","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"炖肉 肉度×3，3肉1填充物，填充物禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 150 5 12 15秒 10天 食材1 食材2 食材3 食材4 怪物肉 大肉 大肉 浆果、冰 怪物肉 大肉 小肉 小肉 大肉 大肉 鸡腿 蛙腿 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:2","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"火鸡大餐 鸡腿×2+肉度×0.5，2鸡腿1肉1填充物，两个鸡腿必须是生的。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 60秒 6天 食材1 食材2 食材3 食材4 鸡腿 鸡腿 怪物肉、大肉、小肉 浆果、蘑菇、冰 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:3","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"培根煎蛋 蛋度×2+肉度×1.5，禁蔬菜、水果。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 20 40秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉、大肉 大肉、小肉 高脚鸟蛋 怪物肉、大肉、小肉 怪物肉、大肉、小肉 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:4","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"蜜汁火腿 蜂蜜×1+肉度×2，禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 30 40秒 20天 食材1 食材2 食材3 食材4 蜂蜜 怪物肉 大肉、小肉 大肉、小肉 蜂蜜 怪物肉 大肉 浆果 蜂蜜 蜂蜜 怪物肉 大肉 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:5","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"果仁杂烩 烤桦树果+水果×1.5，禁冰、蔬菜。 饥饿 精神 生命 烹饪时间 腐烂时间 12.5 5 30 40秒 15天 食材1 食材2 食材3 食材4 烤桦树果 浆果 浆果 浆果 烤桦树果 烤桦树果 浆果 浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:6","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"波兰水饺 禁树枝。 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 20秒 20天 食材1 食材2 食材3 食材4 鸡蛋 鸡蛋 怪物肉 蘑菇 高脚鸟蛋 浆果 怪物肉 蘑菇 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:7","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"火龙果派 饥饿 精神 生命 烹饪时间 腐烂时间 75 5 40 40秒 15天 食材1 食材2 食材3 食材4 火龙果 树枝、浆果 树枝、浆果 树枝、浆果 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:8","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"华夫饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 60 10秒 6天 食材1 食材2 食材3 食材4 黄油 鸡蛋、高脚鸟蛋 浆果 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:9","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"炸鱼条 鱼+树枝 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 40 40秒 10天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:10","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"太妃糖 蜂蜜×3 饥饿 精神 生命 烹饪时间 腐烂时间 25 15 -3 40秒 15天 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:11","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"蝴蝶松饼 饥饿 精神 生命 烹饪时间 腐烂时间 37.5 5 20 40秒 15天 食材1 食材2 食材3 食材4 蝴蝶翅膀 蘑菇 树枝 树枝 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:12","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"粉末蛋糕 玉米+蜂蜜，腐烂时间很久。 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:1:13","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"人物 mod ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:0","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"宝石萝莉 宝石萝莉完整攻略 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:2:1","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":[],"content":"参考资料 Don’t Starve 中文维基 ","date":"2021-03-10","objectID":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/:3:0","tags":[],"title":"饥荒教程","uri":"/posts/%E9%A5%A5%E8%8D%92%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Git 命令 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"本地仓库 # 初始化 git init # 查看文件改动 git diff FILENAME # 添加需要 commit 的文件 git add FILENAME # 提交一个版本，附带描述信息 git commit -m \"descriptions\" # 所有被修改或者已删除的文件提交（不包括新建文件） git commit -a -m \"descriptions\" ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:1","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"远端仓库 # 克隆仓库 git clone https://github.com/USERNAME/REPONAME.git # 为本地仓库添加远端 GitHub 仓库 git remote add origin https://github.com/USERNAME/REPONAME.git # 将已提交的版本推送到远端仓库，方便其他设备同步 git push origin BRANCHNAME # 取回远端仓库版本，对本地仓库进行更新 git pull ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:2","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"分支 # 创建一个分支 git branch BRANCHNAME # 切换分支 git checkout BRANCHNAME # 创建一个分支，并切换过去 git checkout -b BRANCHNAME # 合并分支 git merge BRANCHNAME # 删除分支 git branch -d BRANCHNAME ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:3","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"子模块 # 将一个 Git 仓库添加为当前仓库的子模块 git submodule add https://github.com/USERNAME/REPONAME.git # git clone 含有子模块的项目 # 1.项目已经克隆到了本地 git submodule init git sunmodule update # 或者 git submodule update --init # 2.项目还未克隆到本地 git clone --recurse-submodules https://github.com/USERNAME/REPONAME.git # 或者 git clone --recursive https://github.com/USERNAME/REPONAME.git ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:4","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"替换本地改动 # 丢弃当前文件修改内容 git checkout -- FILENAME # 丢弃本地仓库的所有改动与提交版本 git fetch origin git reset --hard origin/master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:5","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"本地创建仓库并上传至 GitHub 配置 Git。 git bash 输入如下指令： git init git add --all # git add . git commit -m \"descriptions\" git remote add origin https://github.com/USERNAME/REPONAME.git git push -u origin master ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:1:6","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"配置 Git 将your_email@youremail.com改为你的 Github 账号的邮箱，然后一路回车。 ssh-keygen -t rsa -C \"your_email@youremail.com\" 成功的话会在${USERNAME}/下生成.ssh文件夹，进入该文件夹，打开id_rsa.pub文件，复制里面的内容。 回到 Github 网页，登录，点击右上角头像，选择Settings-\u003eSSH and GPG keys-\u003eNew SSH key，Title随便填，Key粘贴你刚复制的内容，然后点击Add SSH key。 测试，git bash 输入如下指令： ssh -T git@github.com 配置用户名和邮箱： git config --global user.name \"USERNAME\" git config --global user.email \"username@email.com\" ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Q\u0026A ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:0","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"无法连接服务器，报错443 问题： git clone 或 git push 等操作时无法连接至服务器，报错内容如下： SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443 答案： 该问题由开启代理软件导致。 到设置-\u003e网络和Internet-\u003e代理中查看地址和端口。 git bash 中输入如下命令（IP_ADDRESS和PORT改为刚才查看的地址和端口）： git config --global http.proxy IP_ADDRESS:PORT # git config --global http.proxy 127.0.0.1:10809 ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:3:1","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"参考 Git Cheat Sheets ","date":"2021-03-10","objectID":"/posts/git-%E6%95%99%E7%A8%8B/:4:0","tags":null,"title":"Git 教程","uri":"/posts/git-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Google, Youtube, Twitter, Instagram, reddit … ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:0:0","tags":null,"title":"科学上网","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":null,"content":"脚本 # centos yum update -y yum install wget -y wget https://s.hijk.art/xray.sh chmod +x xray.sh bash xray.sh # debian or ubuntu apt update apt upgrade -y apt install wget -y wget https://s.hijk.art/xray.sh chmod +x xray.sh bash xray.sh ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:1:0","tags":null,"title":"科学上网","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":null,"content":"v2rayN 更新 4.x 版本后利用分流实现 PAC 效果 参考文章 下载geoip.dat和geosite.dat文件（https://github.com/Loyalsoldier/v2ray-rules-dat），然后覆盖 v2rayN 根目录下的同名文件。 打开 v2RayN，点击设置-\u003e参数设置-\u003ev2rayN设置，勾选更新Core时忽略Geo文件。 打开 v2RayN，点击设置-\u003e路由设置，勾选启用路由高级功能，点击高级功能-\u003e添加规则集-\u003e导入规则-\u003e从剪贴板中导入规则，导入如下规则，别名随意设置。 PAC with ADBlock [ { \"outboundTag\": \"block\", \"domain\": [ \"geosite:category-ads-all\", \"geosite:win-spy\" ] }, { \"outboundTag\": \"proxy\", \"ip\": [ \"geoip:telegram\" ], \"domain\": [ \"geosite:gfw\" ] }, { \"port\": \"0-65535\", \"outboundTag\": \"direct\" } ] PAC [ { \"outboundTag\": \"proxy\", \"ip\": [ \"geoip:telegram\" ], \"domain\": [ \"geosite:gfw\" ] }, { \"port\": \"0-65535\", \"outboundTag\": \"direct\" } ] Global [ { \"outboundTag\": \"proxy\", \"port\": \"0-65535\", } ] ","date":"2021-03-03","objectID":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/:2:0","tags":null,"title":"科学上网","uri":"/posts/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"categories":null,"content":"用于算法竞赛（如ACM、ICPC）的不同算法的集合。 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:0:0","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"动态规划 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:0","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"凸包技巧 https://codeforces.com/contest/319/problem/C #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003eusing namespace std; typedef long long ll; const int MAXN = 105000; int n; ll height[MAXN], tax[MAXN]; ll dp[MAXN]; vector\u003cll\u003e mvals, bvals; int cur = 0; // Suppose the last 3 lines added are : (l1, l2, l3) // Line l2 becomes irrelevant, if l1/l3 x-intersection is to the left of l1/l2 x-intersection bool bad(ll m1, ll b1, ll m2, ll b2, ll m3, ll b3) { // 转为 double 避免溢出 return 1.0 * (b1 - b3) * (m2 - m1) \u003c 1.0 * (b1 - b2) * (m3 - m1); } void add(ll m, ll b) { while ( (int) mvals.size() \u003e= 2 \u0026\u0026 bad(mvals[mvals.size() - 2], bvals[bvals.size() - 2], mvals[mvals.size() - 1], bvals[bvals.size() - 1], m, b)) { mvals.pop_back(); bvals.pop_back(); } mvals.push_back(m); bvals.push_back(b); } void setCur(ll x) { if (cur \u003e (int) mvals.size() - 1) cur = (int) mvals.size() - 1; // Best-line pointer goes to the right only when queries are non-decreasing (x argument grows) while (cur \u003c (int) mvals.size() - 1 \u0026\u0026 1.0 * mvals[cur + 1] * x + bvals[cur + 1] \u003c= 1.0 * mvals[cur] * x + bvals[cur]) cur++; } int main() { //freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%I64d\", \u0026height[i]); for (int i = 1; i \u003c= n; i++) scanf(\"%I64d\", \u0026tax[i]); // Formula is dp[i] = min(tax[j] * height[i] + dp[j] | j = 1 .. i - 1) // Here tax[j] is considered as m value, and dp[j] as b value in line equation y = m * x + b for (int i = 1; i \u003c= n; i++) { if (i == 1) { dp[i] = 0; } else { setCur(height[i]); dp[i] = mvals[cur] * height[i] + bvals[cur]; } add(tax[i], dp[i]); } cout \u003c\u003c dp[n]; return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:1","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"最长递增序列 https://informatics.msk.ru/mod/statements/view3.php?id=766\u0026chapterid=1794 $O(N \\log N)$ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = 1000 * 1000 * 1000; int n; int k, b, m; int a[MAXN]; int d[MAXN]; int ind[MAXN], pr[MAXN]; vector \u003cint\u003e ansv; int ans = 1; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); scanf(\"%d %d %d %d\", \u0026a[1], \u0026k, \u0026b, \u0026m); for (int i = 2; i \u003c= n; i++) a[i] = (k * a[i - 1] + b) % m; d[0] = -INF; for (int i = 1; i \u003c= n; i++) d[i] = INF; for (int i = 1; i \u003c= n; i++) { int pos = upper_bound(d + 1, d + n + 1, a[i]) - d; if (d[pos - 1] \u003c a[i] \u0026\u0026 a[i] \u003c d[pos]) { d[pos] = a[i]; ind[pos] = i; pr[i] = ind[pos - 1]; if (pos \u003e ans) { ans = pos; } } } if (ans == 1) { printf(\"%d\", a[1]); } else { int cur = ind[ans]; while (cur != 0) { ansv.push_back(a[cur]); cur = pr[cur]; } for (int i = (int) ansv.size() - 1; i \u003e= 0; i--) printf(\"%d \", ansv[i]); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:1:2","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"数据结构 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:0","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"笛卡尔树 Balanced Binary Search Tree https://informatics.msk.ru/mod/statements/view3.php?chapterid=2782 $O(\\log N)$ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int mod = 1000 * 1000 * 1000; struct node { int x, y; node *l, *r; node(int new_x, int new_y) { x = new_x; y = new_y; l = NULL; r = NULL; } }; typedef node * pnode; void merge(pnode \u0026t, pnode l, pnode r) { if (l == NULL) t = r; else if (r == NULL) t = l; else if (l-\u003ey \u003e r-\u003ey) { merge(l-\u003er, l-\u003er, r); t = l; } else { merge(r-\u003el, l, r-\u003el); t = r; } } void split(pnode t, int x, pnode \u0026l, pnode \u0026r) { if (t == NULL) l = r = NULL; else if (t-\u003ex \u003e x) { split(t-\u003el, x, l, t-\u003el); r = t; } else { split(t-\u003er, x, t-\u003er, r); l = t; } } void add(pnode \u0026t, pnode a) { if (t == NULL) t = a; else if (a-\u003ey \u003e t-\u003ey) { split(t, a-\u003ex, a-\u003el, a-\u003er); t = a; } else { if (t-\u003ex \u003c a-\u003ex) add(t-\u003er, a); else add(t-\u003el, a); } } int next(pnode t, int x) { int ans = -1; while (t != NULL) { if (t-\u003ex \u003c x) t = t-\u003er; else { if (ans == -1 || ans \u003e t-\u003ex) ans = t-\u003ex; t = t-\u003el; } } return ans; } int n, ans, x; char qt, prev_qt; pnode root = NULL, num; int main() { //freopen(\"input.txt\",\"r\",stdin); //freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\\n\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%c %d\\n\", \u0026qt, \u0026x); if (qt == '+') { if (prev_qt == '?') x = (x + ans) % mod; num = new node(x, rand()); add(root, num); } else { ans = next(root, x); printf(\"%d\\n\", ans); } prev_qt = qt; } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:1","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"带有隐式键的笛卡尔树 https://informatics.msk.ru/mod/statements/view3.php?chapterid=111240 $O(\\log N)$ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003cutility\u003e#include \u003ccstring\u003e#include \u003ciomanip\u003e using namespace std; const int INF = 2 * 1000 * 1000 * 1000; struct node { int y, val; int sz, mn; bool rev; node *l, *r; node (int new_val, int new_y) { y = new_y; val = new_val; sz = 1; mn = val; rev = false; l = NULL; r = NULL; } }; typedef node * pnode; int getsize(pnode t) { if (t == NULL) return 0; return t-\u003esz; } int getmin(pnode t) { if (t == NULL) return INF; return t-\u003emn; } void update(pnode t) { if (t == NULL) return; t-\u003esz = getsize(t-\u003el) + 1 + getsize(t-\u003er); t-\u003emn = min(t-\u003eval, min(getmin(t-\u003er), getmin(t-\u003el))); } void push(pnode t) { if (t \u0026\u0026 t-\u003erev) { swap(t-\u003el, t-\u003er); if (t-\u003el) t-\u003el-\u003erev ^= true; if (t-\u003er) t-\u003er-\u003erev ^= true; t-\u003erev = false; } } void merge(pnode \u0026t, pnode l, pnode r) { push(l); push(r); if (l == NULL) t = r; else if (r == NULL) t = l; else if (l-\u003ey \u003e r-\u003ey) { merge(l-\u003er, l-\u003er, r); t = l; } else { merge(r-\u003el, l, r-\u003el); t = r; } update(t); } void split(pnode t, pnode \u0026l, pnode \u0026r, int x, int add = 0) { push(t); if (t == NULL) { l = r = NULL; return; } int key = getsize(t-\u003el) + 1 + add; if (x \u003c= key) { split(t-\u003el, l, t-\u003el, x, add); r = t; } else { split(t-\u003er, t-\u003er, r, x, add + getsize(t-\u003el) + 1); l = t; } update(t); } void reverse(pnode t, int l, int r) { pnode a, b; split(t, t, a, l, 0); split(a, a, b, r - l + 2, 0); a-\u003erev ^= true; merge(t, t, a); merge(t, t, b); } int getmin(pnode t, int l, int r) { int ans; pnode a, b; split(t, t, a, l, 0); split(a, a, b, r - l + 2, 0); ans = getmin(a); merge(t, t, a); merge(t, t, b); return ans; } int n, m; int qt, l, r; pnode root = NULL, add; int main() { //freopen(\"input.txt\",\"r\",stdin); //freopen(\"output.txt\",\"w\",stdout); scanf(\"%d %d\\n\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { int x; scanf(\"%d\", \u0026x); add = new node(x, rand()); merge(root, root, add); } for (int i = 1; i \u003c= m; i++) { scanf(\"%d %d %d\",\u0026qt, \u0026l, \u0026r); if (qt == 1) { reverse(root, l, r); } else { printf(\"%d\\n\", getmin(root, l, r)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:2","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"树状数组 $O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3317 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; int a[MAXN]; long long f[MAXN]; char q; int l, r; void update(int pos, int delta) { for (; pos \u003c= n; pos = (pos | (pos + 1))) f[pos] += delta; } long long sum(int pos) { long long res = 0; for (; pos \u003e 0; pos = (pos \u0026 (pos + 1)) - 1) res += f[pos]; return res; } long long sum(int l, int r) { return sum(r) - sum(l - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%d\", \u0026a[i]); update(i, a[i]); } scanf(\"%d\\n\", \u0026m); for (int i = 1; i \u003c= m; i++) { scanf(\"%c %d %d\\n\", \u0026q, \u0026l, \u0026r); if (q == 's') { cout \u003c\u003c sum(l, r) \u003c\u003c \" \"; } else { int delta = r - a[l]; a[l] = r; update(l, delta); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:3","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"二维树状数组 $O((\\log N)^2)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3013 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 1050; int n, m; int qn; char q[10]; int f[MAXN][MAXN]; void update(int x, int y, int delta) { for (int i = x; i \u003c= n; i = i | (i + 1)) for (int j = y; j \u003c= m; j = j | (j + 1)) f[i][j] += delta; } int getSum(int x, int y) { int res = 0; for (int i = x; i \u003e 0; i = (i \u0026 (i + 1)) - 1) for (int j = y; j \u003e 0; j = (j \u0026 (j + 1)) - 1) res += f[i][j]; return res; } int getSum(int xFrom, int xTo, int yFrom, int yTo) { return getSum(xTo, yTo) - getSum(xTo, yFrom - 1) - getSum(xFrom - 1, yTo) + getSum(xFrom - 1, yFrom - 1); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\\n\", \u0026n, \u0026qn); m = n; for (int i = 1; i \u003c= qn; i++) { scanf(\"%s\", \u0026q); if (q[0] == 'A') { int x, y; scanf(\"%d %d\\n\", \u0026x, \u0026y); update(x, y, 1); } else { int xFrom, xTo, yFrom, yTo; scanf(\"%d %d %d %d\\n\", \u0026xFrom, \u0026yFrom, \u0026xTo, \u0026yTo); if (xFrom \u003e xTo) swap(xFrom, xTo); if (yFrom \u003e yTo) swap(yFrom, yTo); printf(\"%d\\n\", getSum(xFrom, xTo, yFrom, yTo)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:4","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"隐式的线段树 时间复杂度：$O(\\log N)$ 空间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3327 #include \u003ciostream\u003e#include \u003ccstdio\u003e#include \u003ccstdlib\u003e using namespace std; typedef long long ll; struct Node { ll sum; Node *l, *r; Node() : sum(0), l(NULL), r(NULL) { } }; void add(Node *v, int l, int r, int q_l, int q_r, ll val) { if (l \u003e r || q_r \u003c l || q_l \u003e r) return; if (q_l \u003c= l \u0026\u0026 r \u003c= q_r) { v -\u003e sum += val; return; } int mid = (l + r) \u003e\u003e 1; if (v -\u003e l == NULL) v -\u003e l = new Node(); if (v -\u003e r == NULL) v -\u003e r = new Node(); add(v -\u003e l, l, mid, q_l, q_r, val); add(v -\u003e r, mid + 1, r, q_l, q_r, val); } ll get(Node *v, int l, int r, int pos) { if (!v || l \u003e r || pos \u003c l || pos \u003e r) return 0; if (l == r) return v -\u003e sum; int mid = (l + r) \u003e\u003e 1; return v -\u003e sum + get(v -\u003e l, l, mid, pos) + get(v -\u003e r, mid + 1, r, pos); } int n, m, t, x, y, val; char c; int main() { //freopen(\"input.txt\", \"r\", stdin); //freopen(\"output.txt\", \"w\", stdout); Node *root = new Node(); scanf(\"%d\", \u0026n); for (int i = 0; i \u003c n; i++) { scanf(\"%d\", \u0026x); add(root, 0, n - 1, i, i, x); } scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; i++) { scanf(\"\\n%c\", \u0026c); if (c == 'a') { scanf(\"%d%d%d\", \u0026x, \u0026y, \u0026val); add(root, 0, n - 1, --x, --y, val); } else { scanf(\"%d\", \u0026x); printf(\"%I64d \", get(root, 0, n - 1, --x)); } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:5","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"最小队列 时间复杂度：$O(1)$ https://informatics.msk.ru//mod/statements/view.php?chapterid=756 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 205000; int n, m; deque \u003c pair \u003cint, int\u003e \u003e d; int a[MAXN]; void enqueue(int x) { int num = 1; while (!d.empty() \u0026\u0026 d.back().first \u003e x) { num += d.back().second; d.pop_back(); } d.push_back(make_pair(x, num)); } void dequeue() { if (d.front().second == 1) { d.pop_front(); } else { d.front().second--; } } int getMin() { return d.front().first; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); for (int i = 1; i \u003c= m; i++) { enqueue(a[i]); } printf(\"%d\\n\", getMin()); for (int i = m + 1; i \u003c= n; i++) { dequeue(); enqueue(a[i]); printf(\"%d\\n\", getMin()); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:6","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"线段树（加法-最小间隔-最大间隔） https://codeforces.com/contest/1263/problem/E #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 1000 * 1000 + 100; const int INF = (int) 1e9; struct node { int mx, mn; int add; }; int n; int val[MAXN]; string s; int pos; node tree[4 * MAXN]; void add(int v, int L, int R, int l, int r, int val) { if (l \u003e r) return; if (L == l \u0026\u0026 R == r) { tree[v].add += val; } else { int mid = L + (R - L) / 2; add(2 * v + 1, L, mid, l, min(mid, r), val); add(2 * v + 2, mid + 1, R, max(mid + 1, l), r, val); tree[v].mx = max(tree[2 * v + 1].mx + tree[2 * v + 1].add, tree[2 * v + 2].mx + tree[2 * v + 2].add); tree[v].mn = min(tree[2 * v + 1].mn + tree[2 * v + 1].add, tree[2 * v + 2].mn + tree[2 * v + 2].add); } } int getMin(int v, int L, int R, int l, int r) { if (l \u003e r) { return INF; } if (L == l \u0026\u0026 R == r) { return tree[v].mn + tree[v].add; } int mid = L + (R - L) / 2; return tree[v].add + min(getMin(2 * v + 1, L, mid, l, min(mid, r)), getMin(2 * v + 2, mid + 1, R, max(l, mid + 1), r)); } int getMax(int v, int L, int R, int l, int r) { if (l \u003e r) { return -INF; } if (L == l \u0026\u0026 R == r) { return tree[v].mx + tree[v].add; } int mid = L + (R - L) / 2; return tree[v].add + max(getMax(2 * v + 1, L, mid, l, min(mid, r)), getMax(2 * v + 2, mid + 1, R, max(l, mid + 1), r)); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\\n\", \u0026n); getline(cin, s); pos = 0; for (int i = 0; i \u003c (int) s.length(); i++) { if (s[i] == 'L') { if (pos \u003e 0) pos--; } else if (s[i] == 'R') { pos++; } else { int newVal = 0; if (s[i] == '(') { newVal = 1; } else if (s[i] == ')') { newVal = -1; } int delta = newVal - val[pos]; val[pos] = newVal; add(0, 0, n - 1, pos, n - 1, delta); } int mn = getMin(0, 0, n - 1, 0, n - 1); int lastVal = getMin(0, 0, n - 1, n - 1, n - 1); if (mn \u003c 0 || lastVal != 0) { printf(\"%d \", -1); } else { printf(\"%d \", getMax(0, 0, n - 1, 0, n - 1)); } } cout \u003c\u003c endl; return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:7","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"线段树（分配-求和） https://codeforces.com/gym/100093 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int zero = -1; struct node { long long sum; int val; int size; }; int n, m; char qt; int x, l, r; int a[MAXN]; vector \u003cnode\u003e tree; void build (int v, int L, int R, int a[]) { if (L == R) { tree[v].sum = tree[v].val = a[L]; tree[v].size = 1; } else { int mid = L + (R - L) / 2; build(2 * v, L, mid, a); build(2 * v + 1, mid + 1, R, a); tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum; tree[v].val = zero; tree[v].size = tree[2 * v + 1].size + tree[2 * v].size; } } void push(int v) { if (tree[v].val == zero) return; if (tree[v].size != 1) { tree[2 * v].val = tree[v].val; tree[2 * v + 1].val = tree[v].val; } tree[v].sum = 1ll * tree[v].size * tree[v].val; tree[v].val = zero; } void assign(int v, int L, int R, int l, int r, int val) { if (l \u003e r) return; push(v); if (L == l \u0026\u0026 R == r) { tree[v].val = val; tree[v].sum = 1ll * val * tree[v].size; } else { int mid = L + (R - L) / 2; assign(2 * v, L, mid, l, min(mid, r), val); assign(2 * v + 1, mid + 1, R, max(mid + 1, l), r, val); push(2 * v); push(2 * v + 1); tree[v].sum = tree[2 * v].sum + tree[2 * v + 1].sum; } push(v); } long long getsum(int v, int L, int R, int l, int r) { if (l \u003e r) return 0; push(v); if (l == L \u0026\u0026 r == R) return tree[v].sum; int mid = L + (R - L) / 2; long long res = getsum(2 * v, L, mid, l, min(mid, r)) + getsum(2 * v + 1, mid + 1, R, max(l, mid + 1), r); return res; } int main() { assert(freopen(\"sum.in\",\"r\",stdin)); assert(freopen(\"sum.out\",\"w\",stdout)); scanf(\"%d %d\\n\", \u0026n, \u0026m); tree.resize(4 * n); build(1, 1, n, a); for (int i = 1; i \u003c= m; i++) { scanf(\"%c\", \u0026qt); if (qt == 'A') { scanf(\"%d %d %d\\n\", \u0026l, \u0026r, \u0026x); assign(1, 1, n, l, r, x); } else { scanf(\"%d %d\\n\", \u0026l, \u0026r); cout \u003c\u003c getsum(1, 1, n, l, r) \u003c\u003c endl; } } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:8","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"线段树（最小值-值更新） 预先计算：$O(N \\log N)$ 查询：$O(1)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; const int INF = (int) 1e9; int n, num, qn; int a[MAXN]; int tree[4 * MAXN]; int l, r; int getMax(int l, int r) { l = num + l - 1; r = num + r - 1; int res = -INF; while (l \u003c= r) { if (l \u0026 1) { res = max(res, tree[l]); l++; } if (r % 2 == 0) { res = max(res, tree[r]); r--; } l /= 2; r /= 2; } return res; } void update(int pos, int val) { pos = num + pos - 1; tree[pos] = val; pos /= 2; while (pos \u003e= 1) { tree[pos] = max(tree[pos * 2], tree[pos * 2 + 1]); pos /= 2; } } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); num = 1; while (num \u003c n) num *= 2; for (int i = num; i \u003c 2 * num; i++) { if (i - num + 1 \u003c= n) tree[i] = a[i - num + 1]; else tree[i] = -INF; } for (int i = num - 1; i \u003e= 1; i--) { tree[i] = max(tree[i * 2], tree[i * 2 + 1]); } scanf(\"%d\", \u0026qn); for (int i = 1; i \u003c= qn; i++) { scanf(\"%d %d\", \u0026l, \u0026r); printf(\"%d \", getMax(l, r)); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:9","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"稀疏表 预先计算：$O(N)$ 查询：$O(\\log N)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=3309 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 2 * 105000; const int MAXLOG = 20; int n, m; int a[MAXN]; int table[MAXLOG][MAXN]; int numlog[MAXN]; void buildTable() { numlog[1] = 0; for (int i = 2; i \u003c= n; i++) numlog[i] = numlog[i / 2] + 1; for (int i = 0; i \u003c= numlog[n]; i++) { int curlen = 1 \u003c\u003c i; for (int j = 1; j \u003c= n; j++) { if (i == 0) { table[i][j] = a[j]; continue; } table[i][j] = max(table[i - 1][j], table[i - 1][j + curlen / 2]); } } } int getMax(int l, int r) { int curlog = numlog[r - l + 1]; return max(table[curlog][l], table[curlog][r - (1 \u003c\u003c curlog) + 1]); } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) scanf(\"%d\", \u0026a[i]); buildTable(); scanf(\"%d\", \u0026m); for (int i = 1; i \u003c= m; i++) { int l, r; scanf(\"%d %d\", \u0026l, \u0026r); printf(\"%d \", getMax(l, r)); } return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:2:10","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"几何 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:0","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"最近点对 时间复杂度：$O(N \\log N)$ https://www.spoj.com/problems/CLOPPAIR/ #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; #define sqr(x) ((x) * (x)) const double inf = 1e100; const int MAXN = 105000; struct point { double x, y; int ind; }; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } double dist(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } int n; int a[MAXN]; point p[MAXN], tmp[MAXN]; double ans = inf; int p1, p2; void updateAnswer(point a, point b) { double d = dist(a, b); if (d \u003c ans) { ans = d; p1 = a.ind; p2 = b.ind; } } void closestPair(int l, int r) { if (l \u003e= r) return; if (r - l == 1) { if (p[l].y \u003e p[r].y) swap(p[l], p[r]); updateAnswer(p[l], p[r]); return; } int m = (l + r) / 2; double mx = p[m].x; closestPair(l, m); closestPair(m + 1, r); int lp = l, rp = m + 1, sz = 1; while (lp \u003c= m || rp \u003c= r) { if (lp \u003e m || ((rp \u003c= r \u0026\u0026 p[rp].y \u003c p[lp].y))) { tmp[sz] = p[rp]; rp++; } else { tmp[sz] = p[lp]; lp++; } sz++; } for (int i = l; i \u003c= r; i++) p[i] = tmp[i - l + 1]; sz = 0; for (int i = l; i \u003c= r; i++) if (abs(p[i].x - mx) \u003c ans) { sz++; tmp[sz] = p[i]; } for (int i = 1; i \u003c= sz; i++) { for (int j = i - 1; j \u003e= 1; j--) { if (tmp[i].y - tmp[j].y \u003e= ans) break; updateAnswer(tmp[i], tmp[j]); } } } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { scanf(\"%lf %lf\", \u0026p[i].x, \u0026p[i].y); p[i].ind = i - 1; } sort(p + 1, p + n + 1, cmp); closestPair(1, n); printf(\"%d %d %.6lf\\n\", min(p1, p2), max(p1, p2), ans); return 0; } #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e using namespace std; #define sqr(a) ((a)*(a)) const double inf = 1e100; const int MAXN = 55000; struct point { double x, y; int ind; void read() { scanf(\"%lf%lf\", \u0026x, \u0026y); } double dist_to(point\u0026 r) { return sqrt(sqr(x - r.x) + sqr(y - r.y)); } bool operator\u003c(const point\u0026r) const { return x \u003c r.x || (x == r.x \u0026\u0026 y \u003c r.y); } }; point aux[MAXN], P[MAXN], v[MAXN]; int vn; int a, b, n; double ans = inf; // ans contains closest distance, a, b - indices of points. void closest_pair(point p[], int n) { if (n \u003c= 1) return ; if (n == 2) { if (p[0].y \u003e p[1].y) swap(p[0], p[1]); double d = p[0].dist_to(p[1]); if (d \u003c ans) ans = d, a = p[0].ind, b = p[1].ind; return; } int m = n / 2; double x = p[m].x; closest_pair(p, m); // left closest_pair(p + m, n - m); //right int il = 0, ir = m, i = 0; while (il \u003c m \u0026\u0026 ir \u003c n) { // merging two halves if (p[il].y \u003c p[ir].y) aux[i ++] = p[il ++]; else aux[i ++] = p[ir ++]; } while (il \u003c m) aux[i ++] = p[il ++]; while (ir \u003c n) aux[i ++] = p[ir ++]; vn = 0; for (int j = 0 ; j \u003c n ; j ++) { // copying back into p p[j] = aux[j]; if (fabs(p[j].x - x) \u003c ans) // looking at the strip of width 2*ans v[vn ++] = p[j]; } for (int j = 0 ; j \u003c vn ; j ++) { // (2*ans) x (ans) box for (int k = j + 1 ; k \u003c vn \u0026\u0026 v[k].y - v[j].y \u003c ans ; k ++) { double d = v[j].dist_to(v[k]); if (ans \u003e d) { ans = d; a = v[k].ind, b = v[j].ind; } } } } int main() { scanf(\"%d\", \u0026n); for (int i = 0 ; i \u003c n ; i++) { P[i].read(); P[i].ind = i; } sort(P, P + n); closest_pair(P, n); printf(\"%d %d %lf\\n\", min(a, b), max(a, b), ans); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:1","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"凸包 Graham-Andrew 方法 时间复杂度：$O(N \\log N)$ https://informatics.msk.ru/mod/statements/view3.php?chapterid=638 https://informatics.msk.ru/mod/statements/view3.php?id=\u0026chapterid=290 #include \u003ciostream\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cvector\u003e#include \u003calgorithm\u003e#include \u003ccmath\u003e using namespace std; #define sqr(x) ((x) * (x)) const double pi = acos(-1.0); struct point { double x, y; }; int n; vector \u003cpoint\u003e p, hull; double ans; bool cmp(point a, point b) { return (a.x \u003c b.x || (a.x == b.x \u0026\u0026 a.y \u003c b.y)); } bool eq(point a, point b) { return (a.x == b.x \u0026\u0026 a.y == b.y); } bool isCCW(point a, point b, point c) { return a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y) \u003e 0; } void setConvexHull(vector \u003cpoint\u003e p, vector \u003cpoint\u003e \u0026h) { sort(p.begin(), p.end(), cmp); p.erase(unique(p.begin(), p.end(), eq), p.end()); vector \u003cpoint\u003e up, down; point head = p[0], tail = p.back(); up.push_back(head); down.push_back(head); for (int i = 1; i \u003c (int) p.size(); i++) { if (i == (int) p.size() - 1 || !isCCW(tail, head, p[i])) { while ( (int) up.size() \u003e= 2 \u0026\u0026 isCCW(up[up.size() - 2], up.back(), p[i]) ) up.pop_back(); up.push_back(p[i]); } if (i == (int) p.size() - 1 || isCCW(tail, head, p[i])) { while ( (int) down.size() \u003e= 2 \u0026\u0026 !isCCW(down[down.size() - 2], down.back(), p[i]) ) down.pop_back(); down.push_back(p[i]); } } h.clear(); for (int i = 0; i \u003c (int) up.size(); i++) h.push_back(up[i]); for (int i = (int) down.size() - 2; i \u003e 0; i--) h.push_back(down[i]); } double dist(point a, point b) { return sqrt(sqr(a.x - b.x) + sqr(a.y - b.y)); } double getPerimeter(vector \u003cpoint\u003e p) { double per = 0; for (int i = 1; i \u003c (int) p.size(); i++) per += dist(p[i - 1], p[i]); per += dist(p.back(), p[0]); return per; } int main() { freopen(\"input.txt\",\"r\",stdin); freopen(\"output.txt\",\"w\",stdout); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c= n; i++) { point tmp; scanf(\"%lf %lf\", \u0026tmp.x, \u0026tmp.y); p.push_back(tmp); } setConvexHull(p, hull); ans = getPerimeter(hull); printf(\"%.1lf\", ans); return 0; } 时间复杂度：$O(sort) + O(N)$ #include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003ccmath\u003e using namespace std; #define sqr(x) ((x) * (x)) const double inf = 1e100, eps = 1e-12; struct point { double x, y; void read() { scanf(\"%lf%lf\", \u0026x, \u0026y); } double r() { return sqrt(x*x+y*y); } void print() { printf(\"%lf %lf\\n\", x, y); } bool operator\u003c(const point\u0026 r) const { if (x \u003c r.x) return 1; if (x \u003e r.x) return 0; return y \u003c r.y; } point operator-(point\u0026 r) { point res = {x - r.x, y - r.y}; return res; } double slope() { if (x == 0.0 \u0026\u0026 y == 0.0) return -inf; if (x == 0.0) return inf; return y/x; } double operator*(const point\u0026 r) { return x*r.y - y*r.x; } double dist_to(point\u0026 r) { return sqrt(sqr(x-r.x)+sqr(y-r.y)); } }; point O; // left-most lower point bool BY_SLOPE(point l, point r) { double ls = (l-O).slope(), rs = (r-O).slope(); if (ls \u003c rs) return 1; if (ls \u003e rs) return 0; return l.dist_to(O) \u003c r.dist_to(O); } // pre: N \u003e= 0, [p, p + N) - points vector\u003cpoint\u003e convex_hull(point *p, int N) { if (N \u003c= 2) return vector\u003cpoint\u003e(p, p + N); sort(p, p + N); O = p[0]; sort(p + 1, p + N, BY_SLOPE); vector\u003cpoint\u003e hull; for (int i = 0 ; i \u003c N ; i ++) { if (i \u003c 3) hull.push_back(p[i]); else { int sz = hull.size(); while (sz \u003e= 2 \u0026\u0026 (p[i] - hull[sz-2])*(hull[sz-1]-hull[sz-2]) \u003e= 0) hull.pop_back(), sz --; hull.push_back(p[i]); } } return hull; }// post: convex hull in hull, given in ccw order vector\u003cpoint\u003e v; int n; point P[21100]; int main() { scanf(\"%d\", \u0026n); for (int i = 0 ; i \u003c n ; i ++) P[i].read(); v = convex_hull(P, n); double p = 0.0, s = 0.0; for (int i = 0 ; i \u003c v.size() ; i ++) { p += (v[i]-v[(i+1)%v.size()]).r(); s += .5*(v[i]*v[(i+1)%v.size()]); } printf(\"%e\\n%e\\n\", p, s); //printf(\"%.1lf\\n\", p); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:3:2","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"图 ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:0","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"Bellman-Ford 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view3.php?id=260\u0026chapterid=178 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105; const int INF = 30000; struct edge { int from, to; int w; }; int n, m; int dist[MAXN]; vector \u003cedge\u003e e; int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { edge curEdge; scanf(\"%d %d %d\", \u0026curEdge.from, \u0026curEdge.to, \u0026curEdge.w); e.push_back(curEdge); } for (int i = 1; i \u003c= n; i++) dist[i] = INF; dist[1] = 0; for (int i = 1; i \u003c= n; i++) { bool changed = false; for (int j = 0; j \u003c m; j++) { int from = e[j].from, to = e[j].to, w = e[j].w; if (dist[from] != INF \u0026\u0026 dist[from] + w \u003c dist[to]) { dist[to] = dist[from] + w; changed = true; } } if (!changed) break; } for (int i = 1; i \u003c= n; i++) printf(\"%d \", dist[i]); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:1","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"二部图匹配 Kuhn 算法 时间复杂度：$O(N \\times M)$ https://informatics.msk.ru/mod/statements/view.php?chapterid=1683 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105; int n, m; vector \u003cint\u003e g[MAXN]; bool used[MAXN]; int mt[MAXN]; int ans; bool kuhn(int v) { if (used[v]) return false; used[v] = true; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (mt[to] == 0 || kuhn(mt[to])) { mt[to] = v; return true; } } return false; } int main() { //assert(freopen(\"input.txt\",\"r\",stdin)); //assert(freopen(\"output.txt\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= n; i++) { for (int j = 1; j \u003c= m; j++) { int can; scanf(\"%d\", \u0026can); if (can) g[i].push_back(j); } } for (int i = 1; i \u003c= n; i++) { memset(used, 0, sizeof(used)); if (kuhn(i)) ans++; } printf(\"%d\\n\", ans); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:2","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"桥搜索 时间复杂度：$O(M)$ https://codeforces.com/gym/100083 #include \u003ciostream\u003e#include \u003cfstream\u003e#include \u003ccmath\u003e#include \u003calgorithm\u003e#include \u003cvector\u003e#include \u003cset\u003e#include \u003cmap\u003e#include \u003cstack\u003e#include \u003cqueue\u003e#include \u003ccstdlib\u003e#include \u003ccstdio\u003e#include \u003cstring\u003e#include \u003ccstring\u003e#include \u003ccassert\u003e#include \u003cutility\u003e#include \u003ciomanip\u003e using namespace std; const int MAXN = 105000; int n, m; vector \u003cint\u003e g[MAXN]; vector \u003cint\u003e ind[MAXN]; int tin[MAXN], mn[MAXN]; bool used[MAXN]; vector \u003cint\u003e bridges; int timer; void dfs(int v, int par = -1) { used[v] = true; timer++; tin[v] = timer; mn[v] = tin[v]; for (int i = 0; i \u003c (int) g[v].size(); i++) { int to = g[v][i]; if (!used[to]) { dfs(to, v); if (mn[to] == tin[to]) { bridges.push_back(ind[v][i]); } mn[v] = min(mn[v], mn[to]); } else if (to != par) { mn[v] = min(mn[v], mn[to]); } } } int main() { assert(freopen(\"bridges.in\",\"r\",stdin)); assert(freopen(\"bridges.out\",\"w\",stdout)); scanf(\"%d %d\", \u0026n, \u0026m); for (int i = 1; i \u003c= m; i++) { int from, to; scanf(\"%d %d\", \u0026from, \u0026to); g[from].push_back(to); ind[from].push_back(i); g[to].push_back(from); ind[to].push_back(i); } for (int i = 1; i \u003c= n; i++) if (!used[i]) dfs(i); sort(bridges.begin(), bridges.end()); printf(\"%d\\n\", (int) bridges.size()); for (int i = 0; i \u003c (int) bridges.size(); i++) printf(\"%d\\n\", bridges[i]); return 0; } ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:4:3","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"参考资料 ADJA/algos: Competitive programming algorithms in C++ - GitHub ","date":"2021-02-24","objectID":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/:5:0","tags":null,"title":"C++ 竞赛算法集合","uri":"/posts/c++-%E7%AB%9E%E8%B5%9B%E7%AE%97%E6%B3%95%E9%9B%86%E5%90%88/"},{"categories":null,"content":"Chrome 网上应用店 uBlock Origin 沙拉查词-聚合词典划词翻译 Imagus Chrono下载管理器 Free Download Manager Tampermonkey Bitwarden - 免费密码管理器 Augmented Steam ","date":"2021-02-21","objectID":"/posts/chrome-%E6%88%96-edge-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95/:1:0","tags":null,"title":"Chrome 或 Edge 浏览器扩展","uri":"/posts/chrome-%E6%88%96-edge-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95/"},{"categories":null,"content":"Edge 外接程序 BETA uBlock Origin 沙拉查词-聚合词典划词翻译 Tampermonkey Bitwarden - 免费密码管理器 Augmented Steam ","date":"2021-02-21","objectID":"/posts/chrome-%E6%88%96-edge-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95/:2:0","tags":null,"title":"Chrome 或 Edge 浏览器扩展","uri":"/posts/chrome-%E6%88%96-edge-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%A9%E5%B1%95/"},{"categories":null,"content":"Chocolatey https://chocolatey.org/ @\"%SystemRoot%\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command \"iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))\" \u0026\u0026 SET \"PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin\" Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1')) ","date":"2021-02-20","objectID":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:1:0","tags":null,"title":"Windows 包管理工具","uri":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"Scoop https://scoop.sh/ https://github.com/lukesampson/scoop Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh') ","date":"2021-02-20","objectID":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:2:0","tags":null,"title":"Windows 包管理工具","uri":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"Windows Package Manager CLI (winget) https://github.com/microsoft/winget-cli ","date":"2021-02-20","objectID":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:3:0","tags":null,"title":"Windows 包管理工具","uri":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"参考资料","date":"2021-02-20","objectID":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/:4:0","tags":null,"title":"Windows 包管理工具","uri":"/posts/windows-%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"categories":null,"content":"A 常量指针： 常量指针本质上是个指针，只不过这个指针指向的对象是常量。 特点： const 的位置在指针声明运算符 * 的左侧。只要 const 位于 * 的左侧，无论它在类型名的左边或右边，都表示指向常量的指针。 （可以这样理解，* 左侧表示指针指向的对象，该对象为常量，那么该指针为常量指针。） const int * p1; int const * p2; const int c_var = 8; int var = 6; const int *p3 = \u0026c_var; *p3 = 6; // error C3892: “p3”: 不能给常量赋值 p3 = \u0026var; // 可以赋值 指针指向的对象不能通过这个指针来修改，也就是说常量指针可以被赋值为变量的地址，之所以叫做常量指针，是限制了通过这个指针修改变量的值。 虽然常量指针指向的对象不能变化，可是因为常量指针本身是一个变量，因此，可以被重新赋值。 指针常量： 指针常量的本质上是个常量，只不过这个常量的值是一个指针。 特点： const 位于指针声明操作符右侧，表明该对象本身是一个常量，* 左侧表示该指针指向的类型，即以 * 为分界线，其左侧表示指针指向的类型，右侧表示指针本身的性质。 const int c_var = 8; int var = 6; int * const c_p1 = \u0026c_var; // error C2440: “初始化”: 无法从“const int *”转换为“int *” int * const c_p2 = \u0026var; c_p1 = \u0026var; // error C3892: “c_p1”: 不能给常量赋值 *c_p2 = 6; 指针常量的值是指针，这个值因为是常量，所以指针本身不能改变。 指针的内容可以改变。 ","date":"2021-02-19","objectID":"/posts/c++-%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"C++ 教程","uri":"/posts/c++-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"B 重载： 是指同一可访问区内被声明几个具有不同参数列（参数的类型、个数、顺序）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。 class A { public: void fun(int tmp); void fun(float tmp); // 重载 参数类型不同（相对于上一个函数） void fun(int tmp, float tmp1); // 重载 参数个数不同（相对于上一个函数） void fun(float tmp, int tmp1); // 重载 参数顺序不同（相对于上一个函数） int fun(int tmp); // error C2556: “int A::fun(int)”: 重载函数与“void A::fun(int)”只是在返回类型上不同 }; 隐藏： 是指派生类的函数屏蔽了与其同名的基类函数，主要只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。 class Base { public: void fun(int tmp, float tmp1) { cout \u003c\u003c \"Base::fun(int tmp, float tmp1)\" \u003c\u003c endl; } }; class Derive : public Base { public: void fun(int tmp) { cout \u003c\u003c \"Derive::fun(int tmp)\" \u003c\u003c endl; } // 隐藏基类中的同名函数 }; int main() { Derive ex; ex.fun(1); // Derive::fun(int tmp) ex.fun(1, 0.01); // error C2660: “Derive::fun”: 函数不接受 2 个参数 return 0; } 重写(覆盖)： 是指派生类中存在重新定义的函数。函数名、参数列表、返回值类型都必须同基类中被重写的函数一致，只有函数体不同。派生类调用时会调用派生类的重写函数，不会调用被重写函数。重写的基类中被重写的函数必须有virtual修饰。 class Base { public: virtual void fun(int tmp) { cout \u003c\u003c \"Base::fun(int tmp)\" \u003c\u003c endl; } }; class Derive : public Base { public: virtual void fun(int tmp) { cout \u003c\u003c \"Derive::fun(int tmp)\" \u003c\u003c endl; } // 重写基类中的同名函数 }; int main() { Base *p = new Derive(); p-\u003efun(3); // Derive::fun(int) return 0; } ","date":"2021-02-19","objectID":"/posts/c++-%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"C++ 教程","uri":"/posts/c++-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"freeCodeCamp 2018 年新版课程，包括响应式 Web 设计、算法和数据结构、前端库和框架、数据可视化、API 和微服务、信息安全和质量保证和面试攻略等方面。 ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:0:0","tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":null,"content":"响应式 Web 设计 ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:1:0","tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":null,"content":"HTML 基础 HTML的全称是HyperText Markup Language（超文本标记语言），它是一种用来描述网页结构的标记语言。 文档类型和结构 \u003c!DOCTYPE html\u003e \u003c!--DOCTYPE 一定要大写；html 表示版本为 HTML5，大小写均可--\u003e \u003chtml\u003e \u003chead\u003e \u003c!--link、meta、title 和 style 都应该放入 head 标签--\u003e \u003ctitle\u003etitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch1\u003eheader\u003c/h1\u003e \u003cp\u003etext\u003c/p\u003e \u003c/body\u003e \u003c/html\u003e 常用标签 \u003c!--标题--\u003e \u003ch1\u003e一级标题\u003c/h1\u003e \u003ch2\u003e二级标题\u003c/h2\u003e \u003ch3\u003e三级标题\u003c/h3\u003e \u003ch4\u003e四级标题\u003c/h4\u003e \u003ch5\u003e五级标题\u003c/h5\u003e \u003ch6\u003e六级标题\u003c/h6\u003e \u003c!--文本媒体--\u003e \u003cp\u003e段落\u003c/p\u003e \u003cmain\u003e主要内容\u003c/main\u003e \u003cimg src=\"https://test.jpg\" alt=\"图片\"\u003e \u003cdiv\u003e\u003c/div\u003e \u003chr\u003e \u003c!--特效--\u003e \u003cstrong\u003e加粗\u003c/strong\u003e \u003cem\u003e斜体\u003c/em\u003e \u003cu\u003e下划线\u003c/u\u003e \u003cs\u003e删除线\u003c/s\u003e \u003c!--锚点--\u003e \u003ca href=\"https://test.jpg\" target=\"_blank\"\u003e锚点-1-新标签页网页间跳转\u003c/a\u003e \u003ca href=\"#contacts-header\"\u003e锚点-2-网页内跳转\u003c/a\u003e \u003ch2 id=\"contacts-header\"\u003eContacts\u003c/h2\u003e \u003ca href=\"#\"\u003e锚点-3-固定链接\u003c/a\u003e \u003c!--列表--\u003e \u003cul\u003e \u003cli\u003e无序列表1\u003c/li\u003e \u003cli\u003e无序列表2\u003c/li\u003e \u003c/ul\u003e \u003col\u003e \u003cli\u003e有序列表1\u003c/li\u003e \u003cli\u003e有序列表2\u003c/li\u003e \u003c/ol\u003e lorem ipsum text: 占位符 表单 \u003cform action=\"/url\"\u003e \u003cinput type=\"text\" placeholder=\"占位符\" required\u003e \u003c!--必填--\u003e \u003c!--label 标签设置 for 属性，让其值与按钮的 id 属性值相等--\u003e \u003c!--所有关联的单选按钮应该拥有相同的 name 属性--\u003e \u003clabel for=\"A\"\u003e\u003cinput type=\"radio\" id=\"A\" name=\"A-B\"\u003e单选按钮-A\u003c/label\u003e \u003clabel for=\"B\"\u003e\u003cinput type=\"radio\" id=\"B\" name=\"A-B\" checked\u003e单选按钮-B\u003c/label\u003e \u003c!--默认选中--\u003e \u003clabel for=\"C\"\u003e\u003cinput type=\"checkbox\" id=\"C\" name=\"C-D\"\u003e多选按钮-C\u003c/label\u003e \u003clabel for=\"D\"\u003e\u003cinput type=\"checkbox\" id=\"D\" name=\"C-D\"\u003e多选按钮-D\u003c/label\u003e \u003cbutton type=\"submit\"\u003e提交按钮\u003c/button\u003e \u003c/form\u003e ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:1:1","tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":null,"content":"CSS 基础 CSS的全称是Cascading Style Sheet（层叠样式表），它主要用来控制网页的样式。 CSS 的选择器区分大小写，因此要谨慎使用大写。 内联样式和内部样式 使用 CSS 的三种方式： 内联样式：直接在 HTML 元素里使用style属性。 内部样式：在style标签里编写样式规则。 外部样式：创建一个单独的.css文件，然后在文件中编写样式规则，最后在文档中引用该文件。（常用） \u003c!-- 内联样式 --\u003e \u003ch2 style=\"color: red;\"\u003eheader\u003c/h2\u003e \u003c!-- 内部样式，style 定义在 head 标签中 --\u003e \u003cstyle\u003e .blue-class { color: blue; } \u003c/style\u003e \u003cp class=\"blue-class\"\u003etext\u003c/p\u003e 外部样式 h2 {} /* 标签选择器 */ .class-selector {} /* class 选择器 */ #id-selector {} /* id 选择器*/ .links {} /* 超链接选择器 */ a:hover {} /* 锚点的悬停状态选择器 */ [type=\"radio\"] {} /* 属性选择器 */ 调整元素边距 所有的 HTML 元素基本都是以矩形为基础。 每个 HTML 元素周围的矩形空间由三个重要的属性来控制：padding（内边距），margin（外边距）和border（边框）。 .red-box { background-color: red; color: black; border-style: solid; border-color: black; border-width: 5px; /* border: 5px solid black; */ padding: 20px; /* padding-top: 40px; padding-right: 20px; padding-bottom: 20px; padding-left: 40px; padding: 40px 20px 20px 40px; /* 上右下左 */ */ margin: 20px; /* 若为负值，元素会变得更大 */ /* margin-top: 40px; margin-right: 20px; margin-bottom: 20px; margin-left: 40px; margin: 40px 20px 20px 40px; /* 上右下左 */ */ } 长度单位 px 像素，绝对单位 in 英寸，绝对单位 mm 毫米，绝对单位 em 相对单位，基于元素的字体的 font-size 值 rem 相对单位 样式的继承与优先级 若子标签未声明样式规则，则继承父标签的样式。 相同级别选择器之间，后声明的优先级高于先声明的 class选择器优先级高于标签选择器 id选择器优先级高于class选择器 内联样式的优先级高于id选择器 important的优先级最高 .pink-text { color: pink !important; } CSS 变量 :root { --dog-color: brown; /* 定义 CSS 全局变量 */ } .dog { --dog-color: white; /* 定义 CSS 局部变量，覆盖同名全局变量 */ background-color: var(--dog-color, black); /* 使用 CSS 变量，同时设置一个备用值 */ } ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:1:2","tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":null,"content":"应用视觉设计 Applied Visual Design Challenges（应用视觉设计）结合了排版、色彩理论、图形、动画和页面布局等。 常用属性值 color 可用英语颜色单词、#000000、#000、rgb(0,0,0)、rgba(255,255,255,0.5) 0 代表完全透明，1 代表完全不透明 color: red; 文本颜色 background-color: blue; 背景颜色 font font-size: 20px; 文本大小 font-weight: bold; 文本加粗，相当于\u003cstrong\u003e\u003c/strong\u003e font-weight: 600; 文本粗细 font-family: sans-serif, monospace, serif; 文本字体，当前面字体不可用时后面字体作为备用 font-style: italic; 文本斜体，相当于\u003cem\u003e\u003c/em\u003e border border-color: red; 边框颜色 border-width: 2px; 边框粗细 border-style: solid; 边框类型 border-radius: 10px; 圆角，50% 就是圆形 text text-align: left; 文本左对齐 text-align: center; 文本居中 text-align: right; 文本右对齐 text-align: justify; 文本两端对齐 text-decoration: underline; 文本下划线，相当于\u003cu\u003e\u003c/u\u003e text-decoration: line-through; 文本删除线，相当于\u003cs\u003e\u003c/s\u003e text-transform: lowercase; 英文字母全小写 text-transform: uppercase; 英文字母全大写 text-transform: capitalize; 英文字母首字母大写 text-transform: initial; 默认值 text-transform: inherit; 继承父元素的 text-transform text-transform: none; 不改变 line-height: 25px; 行高、行间距 box-shadow: 0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23); 水平偏移量、垂直偏移量、模糊距离、阴影尺寸、颜色 opacity: 0.5; 透明度。1 代表不透明，0.5 代表半透明，0 代表透明 z-index: 2; 指定元素的堆叠次序，取整数，数值大的元素优先显示 位置 在 CSS 里一切 HTML 元素皆为盒子，也就是通常所说的盒模型。块级元素自动从新的一行开始（比如标题、段落以及 div），行内元素排列在上一个元素后（比如图片以及 span）。元素默认按照这种方式布局称为文档的普通流，同时 CSS 提供了position属性来覆盖它。 top、bottom、left和right定义了元素在相应方位的偏移距离。元素将从当前位置，向属性相反的方向偏移。 relative 当元素position: relative;时，它允许你通过 CSS 指定该元素在当前普通流页面下的相对偏移量。 position: relative;并不会改变该元素在普通流布局所占的位置，也不会对其它元素的位置产生影响。 absolute 当元素position: absolute;时，会将元素从当前的文档流里面移除，周围的元素会忽略它。absolute定位参照于最近的已定位祖先元素，如果它的父元素没有添加定位规则（默认是relative），浏览器会继续寻找直到默认的 body 标签。 fixed 当元素position: fixed;时，会将元素从当前的文档流里面移除，其它元素会忽略它。 fixed定位和absolute定位的最明显的区别是fixed定位元素不会随着屏幕滚动而移动。 float 通过元素的float属性来设置。浮动元素不在文档流中，它向左或向右浮动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。通常需要用width属性来指定浮动元素占据的水平空间。可以float: left;或float: right;。 ","date":"2021-02-15","objectID":"/posts/freecodecamp-2018/:1:3","tags":null,"title":"FreeCodeCamp 2018","uri":"/posts/freecodecamp-2018/"},{"categories":null,"content":"LaTeX 常用数学符号、公式。 标量 - 斜体小写 - $a$ 向量 - 粗体小写 - $a$ 矩阵 - 粗体大写 - $A$ ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:0:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"希腊字母 大写字母 代码 小写字母 代码 变量形式 代码 $\\alpha$ \\alpha $\\beta$ \\beta $\\Gamma$ \\Gamma $\\gamma$ \\gamma $\\Delta$ \\Delta $\\delta$ \\delta $\\epsilon$ \\epsilon $\\Theta$ \\Theta $\\theta$ \\theta $\\Lambda$ \\Lambda $\\lambda$ \\lambda $\\mu$ \\mu $\\Pi$ \\Pi $\\pi$ \\pi $\\rho$ \\rho $\\Sigma$ \\Sigma $\\sigma$ \\sigma $\\Phi$ \\Phi $\\phi$ \\phi $\\varphi$ \\varphi $\\Psi$ \\Psi $\\psi$ \\psi $\\Omega$ \\Omega $\\omega$ \\omega ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:1:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"特殊符号 符号 代码 解释 $\\partial$ \\partial 偏导数 $\\nabla$ \\nabla 梯度 $\\ell$ \\ell $\\Complex$ \\Complex \\cnums 复数集 $\\R$ \\Reals \\reals \\R 实数集 $\\Z$ \\Z 整数集 $\\natnums$ \\natnums \\N 自然数集 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:2:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"垂直布局 符号 代码 解释 $x_n$ x_n 下标 $e^x$ e^x 上标 $_u^o$ _u^o 上下标 $\\overset{N}{\\sum}$ \\overset{N}{\\sum} 正上标 $\\underset{i=1}{\\sum}$ \\underset{i=1}{\\sum} 正下标 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:3:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"字体 符号 代码 解释 $\\sqrt{x}$ \\sqrt{x} 平方根 $\\sqrt[3]{x}$ \\sqrt[3]{x} 三次方根 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:4:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"逻辑符与集合论 符号 代码 解释 $\\forall$ \\forall 所有 $\\exist$ \\exists \\exist 存在 $\\in$ \\in \\isin 属于 $\\notin$ \\notin 不属于 $\\subset$ \\subset 包含于 $\\supset$ \\supset 包含 $\\emptyset$ \\emptyset \\empty 空集 $\\varnothing$ \\varnothing 空集 $\\implies$ \\implies 充分 $\\impliedby$ \\impliedby 必要 $\\iff$ \\iff 充分必要 $\\neg$ \\neg \\lnot 非 $\\lor$ \\lor 或 $\\land$ \\land 与 $\\because$ \\because 因为 $\\therefore$ \\therefore 所以 $\\ne$ \\ne \\neq 不等于 $\\approx$ \\approx 约等于 $\\coloneqq$ \\coloneqq 赋值 $\\gt$ \\gt 大于 $\\ge$ \\ge \\geq 大于等于 $\\lt$ \\lt 小于 $\\le$ \\le \\leq 小于等于 $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:5:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"多元运算符 符号 代码 解释 $\\sum$ \\sum 累加 $\\prod$ \\prod 累乘 $\\bigcap$ \\bigcap 累交 $\\bigcup$ \\bigcup 类并 $\\int$ \\int 一重积分 $\\iint$ \\iint 二重积分 $\\iiint$ \\iiint 三重积分 $\\oint$ \\oint 一重环路积分 $\\oiint$ \\oiint 二重环路积分 $\\oiiint$ \\oiiint 三重环路积分 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:6:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"二元运算符 符号 代码 解释 $\\bmod$ \\bmod $x \\pmod a$ x \\pmod a $\\div$ \\div $\\pm$ \\pm \\plusmn $\\oplus$ \\oplus $\\otimes$ \\otimes $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:7:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"常用数学符号 符号 代码 解释 $\\lim$ \\lim $\\ln$ \\ln $\\log$ \\log $\\exp$ \\exp $\\max$ \\max $\\min$ \\min $\\argmax$ \\argmax $\\argmin$ \\argmin $\\sin$ \\sin $\\cos$ \\cos $\\tan$ \\tan $$ `` ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:8:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"矩阵 ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:9:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"参考资料 Supported Functions - KaTeX ","date":"2021-02-11","objectID":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/:10:0","tags":null,"title":"LaTeX 常用数学符号","uri":"/posts/latex-%E5%B8%B8%E7%94%A8%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/"},{"categories":null,"content":"数据结构，是抽象的表示数据的方式；算法，则是计算的一系列有效、通用的步骤。算法与数据结构是程序设计中相辅相成的两个方面，是计算机学科的重要基石。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:0:0","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"树 一棵 n 个节点的树，有 n-1 条边。 一棵 n 个节点的树，有 n 棵子树。 根节点：唯一，无入度的节点 节点的深度：节点距离根节点的距离。 typedef struct treeNode { treeNode(int x): value(x) {} int value; vector\u003ctreeNode*\u003e child; } TreeNode; ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:1:0","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"二叉树 满二叉树：一个高度为 d 的二叉树，有 $2^d-1$ 个节点。即除叶节点外，每个节点都有两个孩子，即节点的出度只为 0 或 2。 完全二叉树：只有最后一层可能未满，且节点严格从左往右排列。即出度为 1 的节点一定只有左孩子；若某节点出度小于 2，则其右边的节点出度为 0。 二叉树第 $i$ 层最多有 $2^{i-1}$ 个节点。 高度为 $d$ 的二叉树最多有 $2^d-1$ 个节点。 class TreeNode(object): def __init__(self, value): self.lchild = None self.rchild = None self.value = 0 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:0","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"遍历 前序遍历 递归法： void preorder(TreeNode* root) { if (!root) return; // 处理节点值 root-\u003eval preorder(root-\u003eleft); preorder(root-\u003eright); } 非递归法： 压栈先右后左 void preorder(TreeNode* root) { if (!root) return; stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); // 处理节点值 root-\u003eval if (root-\u003eright) st.push(root-\u003eright); if (root-\u003eleft) st.push(root-\u003eleft); } } void preorder(TreeNode* root) { stack\u003cTreeNode*\u003e st; whilt (root || !st.empty()) { if (root) { // 处理节点值 root-\u003eval st.push(root); root = root-\u003eleft; } else { root = st.top()-\u003eright; st.pop(); } } } 中序遍历 对于二叉搜索树，中序遍历可以得到一个递增的有序序列 递归法： void inorder(TreeNode* root) { if (!root) return; inorder(root-\u003eleft); // 处理节点值 root-\u003eval inorder(root-\u003eright); } 非递归法： void inorder(TreeNode* root) { stack\u003cTreeNode*\u003e st; while (root || !st.empty()) { if (root) { st.push(root); root = root-\u003eleft; } else { // 处理节点值 st.top()-\u003eval root = st.top()-\u003eright; st.pop(); } } } 后序遍历 后序遍历是删除节点时的顺序 可以配合栈来计算表达式树 递归法： void postorder(TreeNode* root) { if (!root) return; postorder(root-\u003eleft); postorder(root-\u003eright); // 处理节点值 root-\u003eval } 非递归法： 前序遍历的非递归方法先左后右，最后逆序即可 void postorder(TreeNode* root) { if (!root) return; vector\u003cint\u003e res; // 保存遍历结果 stack\u003cTreeNode*\u003e st; st.push(root); while (!st.empty()) { root = st.top(); st.pop(); res.push_back(root-\u003eval); // 保存节点值 if (root-\u003eleft) st.push(st-\u003eleft); if (root-\u003eright) st.push(st-\u003eright); } reverse(res.begin(), res.end()); // 逆序 } 层序遍历 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:1","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"常见问题 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:2:2","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"排序 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:3:0","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"归并排序 void mergeSort() { } void merge() { } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:3:1","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"快速排序 基本思想： 从数组中取出一个数，称之为基数（pivot）。 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域。 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成。 // 把数组分为两半，返回分割中点 int partition(vector\u003cint\u003e arr, int low, int high) { int pivot = arr[low]; while (low \u003c right) { while (low \u003c high \u0026\u0026 arr[high] \u003e pivot) high--; arr[low] = arr[high]; while (low \u003c high \u0026\u0026 arr[low] \u003c= pivot) low++; arr[high] = arr[low]; } arr[low] = pivot; return low; } void quickSort(vector\u003cint\u003e arr, int low, int high) { if (low \u003e= high) return; int mid = partition(arr, low, high); quickSort(arr, low, mid - 1); quickSort(arr, mid + 1, high); } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:3:2","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"总结 排序算法 时间复杂度 稳定性 冒泡排序 $O(n^2)$ 稳定 选择排序 $O(n^2)$ 不稳定 插入排序 $O(n^2)$ 稳定 快速排序 $O(n \\log n)$ 不稳定 归并排序 $O(n \\log n)$ 稳定 堆排序 $O(n \\log n)$ 不稳定 计数排序 $O(n)$ 稳定 基数排序 $O(n)$ 稳定 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:3:3","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"回溯算法 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:4:0","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"N 皇后问题 题目描述：将 N 个皇后放在 N×N 的棋盘上，需保证任意两个皇后不能处于同行、同列或同斜线上。 vector\u003cvector\u003cchar\u003e\u003e solve(int n) { } void dfs(vector\u003cvector\u003cchar\u003e\u003e\u0026 chessboard, int rowNo, int n) { } ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:4:1","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"贪心与分治理论 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:0","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"贪心算法 贪心算法理论 严格来说，贪心算法并不是某些有明确指向的算法，而是代指一类算法思想。在有多种决策可选时，我们会选择一个最优的策略，即所谓的贪心算法。 举一个最简单的例子，田忌赛马。在对方出上等马的时候，我方没有任何一匹马能赢这一局，既然注定是输，那么我们希望尽量减少我们的损失。何谓损失？我们每一局都会用掉一匹马，那么对于必输的局，显然用掉最弱的马是最好的。这里就可以归类出两个名词： 局部目标：在贪心问题中，总归有一个局部的目标。例如在上述场景里，我们希望减少这一轮的损失。这就是一个局部目标。和局部目标对应的是全局目标，全局上来说我们当然希望最终能赢得比赛。 策略：在这个局部情景里，我们有多种可用的决策，例如我们可以挑选任意一匹马应战。 实际上，很多问题都可以拆解为若干个局部问题和局部策略。如果这一类问题满足： 局部问题存在最优解。 局部问题最优可以保证全局问题最优。 那么这个问题就可以通过贪心算法解决。 小技巧：局部问题又称为子问题，很多复杂的原始问题都可以拆解成若干个子问题构成，例如一盘围棋就可以拆解为每次双方执子的小问题。在不同的情景下，子问题的性质是不一样的，对应的解决办法也不一样。 例如： 子问题最优则原始问题最优——贪心算法或者动态规划算法。 子问题最优则原始问题最优，且子问题互相独立——分治算法。 子问题最优不能推导出原始问题最优——暴力搜索等。 算法中的贪心思想 例一：二叉搜索树找最小值 子问题：最小值一定在根节点，左子树（如果存在），右子树（如果存在）三者之一上，因此原问题可以划分为三个子问题。 我们本来可以在左右子树上均查找一次最小值，但是根据二叉查找树的性质，如果左子树存在，那么最小值只可能存在于左子树上。这就是一个贪心的思想，通过只找一边的子树，我们可以将复杂度从O(n)降低至O(log(h))，其中h为树的高度。 例二：二分查找问题 同样，二分查找也存在贪心的思想。在确定left, mid, right后，根据target和mid的大小关系，我们同样只会继续查找左半边或者右半边，这也是因为另一边不可能有目标值了。 贪心问题解决思路 那么对于原始的复杂问题，如何能够知道他是否能被贪心解决呢？ 首先，我们需要将原始问题拆解成子问题，明确子问题的局面以及局面中可进行的操作。实际上不止贪心问题，很多问题都需要这样的拆解过程。 然后我们需要考虑子问题的最优，是否能保证全局最优。如果能的话，我们就可以只考虑如何解子问题，否则就可能需要动态规划或者搜索解了。 最后，我们需要考虑如何使子问题最优，可能有些问题存在乍一看可行的策略，但是我们仍然需要仔细思考甚至证明。以保证没有漏掉什么细节情况。 小技巧：对于第三点，很多同学这里会经常犯错。比如以为贪心做法是对的，但是实际上有问题。例如错误地用贪心解决 01 背包问题（子问题最优，原问题不一定最优）等。所以如果我们觉得某道题目存在贪心策略，最好自己证明一下正确性再实现。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:1","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"分治算法 复杂的原始问题可能可以拆分成若干个子问题，如果子问题之间互相独立（一个子问题的计算结果不依赖于其他子问题），那么原始问题可以被分治法解决。 分治法究竟有什么作用呢？ 简化思维逻辑：在很多情况下，原始问题是非常复杂的，例如排序问题。假设原始我们需要考虑对 1000 个数进行排序，那么利用分治思想我们可以分别对左右的 500 个数进行排序，然后考虑合并两个有序数组。当然，排序 500 个数看起来仍然不容易，但是我们可以继续分治下去，最终我们只需要考虑 1~2 个数的排序策略，这就是经典的归并排序的思想。 分布式算法：虽然在算法学习的过程中少有接触多进程和分布式等思想。但是随着 CPU core 越来越多，能够被分治法拆解的问题显然更方便进行并行计算，从而节省总体时间。因此分治思想在工程实现上具有重要的意义。 效率优化：虽然我们不常用并行解决算法问题，但是在某些情况下仍然能够帮助我们节省计算代价，代表就是快速幂算法。课程在这里不作展开，我们会在例题部分进一步详细讨论。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:2","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"总结 对于复杂的原问题： 如果子问题最优则原问题最优，贪心算法。 如果子问题需要全部求解才能求解原问题，子问题互相独立，分治算法。 如果子问题最优不能保证原问题最优，但是子问题之间不会循环（所谓循环，是指从问题 A 拆解出子问题 B，然后子问题 B 又能拆解出子问题 A），考虑动态规划算法。 更加复杂的情况，我们总是可以考虑暴力搜索解决。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:5:3","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"动态规划 考虑能否将问题规模减小 将问题规模减小的方式有很多种，一些典型的减小方式是动态规划分类的依据，例如线性，区间，树形等。这里考虑数组上常用的两种思路： 每次减少一半：如果每次将问题规模减少一半，原问题有[10,9,2,5]，和[3,7,101,18]，两个子问题的最优解分别为 [2,5] 和 [3,7,101]，但是找不到好的组合方式将两个子问题最优解组合为原问题最优解 [2,5,7,101]。 每次减少一个：记 f(n)f(n) 为以第 nn 个数结尾的最长子序列，每次减少一个，将原问题分为 f(n-1)f(n−1), f(n-2)f(n−2), …, f(1)f(1)，共 n - 1n−1 个子问题。n - 1 = 7n−1=7 个子问题以及答案如下： 以上组合方式可以写成一个式子，即状态转移方程 总结： 解决动态规划问题最难的地方有两点： 如何定义 f(n)f(n) 如何通过 f(1)f(1), f(2)f(2), … f(n - 1)f(n−1) 推导出 f(n)f(n)，即状态转移方程 递归 有了状态转移方程，实际上已经可以直接用递归进行实现了。 自顶向下（记忆化） 递归的解法需要非常多的重复计算，如果有一种办法能避免这些重复计算，可以节省大量计算时间。记忆化就是基于这个思路的算法。在递归地求解子问题 f(1)f(1), f(2)f(2)… 过程中，将结果保存到一个表里，在后续求解子问题中如果遇到求过结果的子问题，直接查表去得到答案而不计算。 对于这种将问题规模不断减少的做法，我们把它称为自顶向下的方法。 自底向上（迭代） 在自顶向下的算法中，由于递归的存在，程序运行时有额外的栈的消耗。 有了状态转移方程，我们就知道如何从最小的问题规模入手，然后不断地增加问题规模，直到所要求的问题规模为止。在这个过程中，我们同样地可以记忆每个问题规模的解来避免重复的计算。这种方法就是自底向上的方法，由于避免了递归，这是一种更好的办法。 但是迭代法需要有一个明确的迭代方向，例如线性，区间，树形，状态压缩等比较主流的动态规划问题中，迭代方向都有相应的模式。参考后面的例题。但是有一些问题迭代法方向是不确定的，这时可以退而求其次用记忆化来做，参考后面的例题。 ","date":"2021-02-09","objectID":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/:6:0","tags":null,"title":"数据结构与算法","uri":"/posts/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"categories":null,"content":"谷歌三件套包括 Google Play 商店（Google Play Store）、Google Play 服务（Google Play Services）和Google 服务框架（Google Services Framework），只有正确安装了这三件套才能访问 Google Play 商店和使用需要 Google Play 服务的 APP。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"安装 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"一键安装 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:1","tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"手动安装 访问 APKMirror。 搜索Google Services Framework，根据安卓版本选择对应的版本下载并安装。（示例：Google Services Framework 10） 搜索Google Play Services，选择最新版并进入，选择arm64-v8a + armeabi-v7a、对应的安卓版本、nodpi，下载并安装。 搜索Google Play Store，选择最新版下载并安装。 若三件套都安装完，并且正确科学上网后还是打不开Google Play 商店，尝试下载旧版本Google Play Services安装。 不推荐使用beta版本。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:2","tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Google Play Services 版本号 版本号示例：20.50.66 (100400-351698872)，其中100400说明： 第 1、2 位表示安卓版本 00 - Android 4.1 02 - Android 5.0 04 - Android 6.0 05 - Wear OS 08 - Android TV 10 - Android 9.0 12 - Android 10 15 - Android 11 第 3、4 位表示CPU架构 03 - armeabi-v7a 04 - armeabi-v7a + arm64-v8a 07 - x86 08 - x86 + x86_64 第 5、6 位表示屏幕 DPI 00 - nodpi 02 - 160dpi 04 - 240dpi 06 - 320dpi 08 - 480dpi 则100400指Android 9.0、arm64-v8a和nodpi。 ","date":"2021-02-08","objectID":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/:1:3","tags":null,"title":"谷歌三件套安装教程","uri":"/posts/%E8%B0%B7%E6%AD%8C%E4%B8%89%E4%BB%B6%E5%A5%97%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Android Debug Bridge (ADB) 是一种功能多样的命令行工具，可让您与安卓设备进行通信。ADB 命令可用于执行各种设备操作（例如安装和调试应用），并提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。 ","date":"2021-02-08","objectID":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":null,"title":"ADB 常用命令","uri":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"准备 手机打开开发者模式。 进入开发者选项，打开USB调试。 手机 USB 连接电脑。 电脑下载 Android SDK Platform Tools，解压后进入文件夹。 运行 cmd，输入以下内容。 ","date":"2021-02-08","objectID":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:1:0","tags":null,"title":"ADB 常用命令","uri":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"命令 提取已安装 APP 的 APK 安装包 # 1.列出所有已安装APP的包名 adb shell pm list packages # 2.获取所需APP的APK文件的完整路径 adb shell pm path XXX.XXX.XXX # 3.根据上一步的输出，提取安装包到电脑当前目录 adb pull /data/app/XXX.XXX.XXX.apk . ","date":"2021-02-08","objectID":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:2:0","tags":null,"title":"ADB 常用命令","uri":"/posts/adb-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"Java 是全球使用最广泛的编程语言。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"准备 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"JDK 下载 Oracle JDK Oracle OpenJDK ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:1","tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"环境变量配置 设置→系统→关于→高级系统设置→环境变量。 在下方的系统变量中找到Path，点击编辑。 点击新建，将JDK的路径下的bin目录粘贴进去。（示例：C:\\Users\\backs\\Downloads\\portable\\jdk-11.0.10\\bin\\） 连续点击确定，保存退出。 打开cmd，输入java -version，若有如下所示输出即为配置成功。 java version \"11.0.10\" 2021-01-19 LTS Java(TM) SE Runtime Environment 18.9 (build 11.0.10+8-LTS-162) Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.10+8-LTS-162, mixed mode) 在任意位置创建 test.java，写入以下内容。 public class test { public static void main(String[] args) { System.out.println(\"Hello World!\"); } } 在该文件夹下打开 cmd，输入以下内容，输出应该为 Hello World!。 javac test.java java test ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:2","tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"IDE Download IntelliJ IDEA: 最好用，Community版免费，Ultimate版收费，学生可白嫖，推荐。 Eclipse: 开源，免费。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:1:3","tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Usage ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"GC 垃圾回收，顾名思义就是释放垃圾占用的空间，从而提升程序性能，防止内存泄露。当一个对象不再被需要时，该对象就需要被回收并释放空间。 Java 内存运行时数据区域包括程序计数器、虚拟机栈、本地方法栈、堆等区域。其中，程序计数器、虚拟机栈和本地方法栈都是线程私有的，当线程结束时，这些区域的生命周期也结束了，因此不需要过多考虑回收的问题。而堆是虚拟机管理的内存中最大的一块，堆中的内存的分配和回收是动态的，垃圾回收主要关注的是堆空间。 调用垃圾回收器的方法 调用垃圾回收器的方法是gc，该方法在System类和Runtime类中都存在。在Runtime类中，方法gc是实例方法，方法System.gc是调用该方法的一种传统而便捷的方法。在System类中，方法gc是静态方法，该方法会调用Runtime类中的gc方法。其实，java.lang.System.gc等价于java.lang.Runtime.getRuntime.gc的简写，都是调用垃圾回收器。方法gc的作用是提示Java虚拟机进行垃圾回收，该方法由系统自动调用，不需要人为调用。该方法被调用之后，由Java虚拟机决定是立即回收还是延迟回收。 finalize 方法 与垃圾回收有关的另一个方法是finalize方法。该方法在Object类中被定义，在释放对象占用的内存之前会调用该方法。该方法的默认实现不做任何事，如果必要，子类应该重写该方法，一般建议在该方法中释放对象持有的资源。 判断对象是否可回收 垃圾回收器在对堆进行回收之前，首先需要确定哪些对象是可回收的。常用的算法有两种，引用计数算法和根搜索算法。 1.引用计数算法 引用计数算法给每个对象添加引用计数器，用于记录对象被引用的计数，引用计数为 0 的对象即为可回收的对象。 虽然引用计数算法的实现简单，判定效率也很高，但是引用计数算法无法解决对象之间循环引用的情况。如果多个对象之间存在循环引用，则这些对象的引用计数永远不为 0，无法被回收。因此 Java 语言没有使用引用计数算法。 2.根搜索算法 主流的商用程序语言都是使用根搜索算法判断对象是否可回收。根搜索算法的思路是，从若干被称为 GC Roots 的对象开始进行搜索，不能到达的对象即为可回收的对象。 在 Java 中，GC Roots 一般包含下面几种对象： 虚拟机栈中引用的对象 本地方法栈中的本地方法引用的对象 方法区中的类静态属性引用的对象 方法区中的常量引用的对象 3.引用的分类 引用计数算法和根搜索算法都需要通过判断引用的方式判断对象是否可回收。 在 JDK 1.2 之后，Java 将引用分成四种，按照引用强度从高到低的顺序依次是： 强引用：在程序代码中普遍存在的引用。垃圾回收器永远不会回收被强引用关联的对象。 软引用：还有用但并非必需的对象。只有在系统将要发生内存溢出异常时，被软引用关联的对象才会被回收。在 JDK 1.2 之后，提供了SoftReference类实现软引用。 弱引用：非必需的对象，其强度低于软引用。被弱引用关联的对象只能存活到下一次垃圾回收发生之前，当垃圾回收器工作时，被弱引用关联的对象一定会被回收。在 JDK 1.2 之后，提供了WeakReference类实现弱引用。 虚引用：最弱的引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。在 JDK 1.2 之后，提供了PhantomReference类实现虚引用。 垃圾回收算法 1.标记—清除算法 标记—清除算法是最基础的垃圾回收算法，后续的垃圾收集算法都是基于标记—清除算法进行改进而得到的。标记—清除算法分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 标记—清除算法有两个主要缺点。一是效率问题，标记和清除的效率都不高，二是空间问题，标记清除之后会产生大量不连续的内存碎片，导致程序在之后的运行过程中无法为较大对象找到足够的连续内存。 2.复制算法 复制算法的将可用内存分成大小相等的两块，每次只使用其中的一块，当用完一块内存时，将还存活着的对象复制到另外一块内存，然后把已使用过的内存空间一次清理掉。 复制算法解决了效率问题。由于每次都是对整个半区进行内存回收，因此在内存分配时不需要考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可。复制算法的优点是实现简单，运行高效，缺点是将内存缩小为了原来的一半，以及在对象存活率较高时复制操作的次数较多，导致效率降低。 3.标记—整理算法 标记—整理算法是根据老年代的特点提出的。标记过程与标记—清除算法一样，但后续步骤不是直接回收被标记的对象，而是让所有存活的对象都向一端移动，然后清除边界以外的内存。 4.分代收集算法 分代收集算法根据对象的存活周期不同将内存划分为多个区域，对每个区域选用不同的垃圾回收算法。 一般把 Java 堆分为新生代和老年代。在新生代中，大多数对象的生命周期都很短，因此选用复制算法。在老年代中，对象存活率高，因此选用标记—清除算法或标记—整理算法。 分配内存与回收策略 Java 堆可以分成新生代和老年代，新生代又可以细分成Eden区、From Survivor区、To Survivor区等。对于不同的对象，有相应的内存分配规则。 1.Minor GC 和 Full GC Minor GC指发生在新生代的垃圾回收操作。因为大多数对象的生命周期都很短，因此Minor GC会频繁执行，一般回收速度也比较快。 Full GC也称Major GC，指发生在老年代的垃圾回收操作。出现了Full GC，经常会伴随至少依次的Minor GC。老年代对象的存活时间长，因此Full GC很少执行，而且执行速度会比Minor GC慢很多。 2.对象优先在 Eden 区分配 大多数情况下，对象在新生代Eden区分配，当Eden区空间不够时，发起Minor GC。 3.大对象直接进入老年代 大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。大对象对于虚拟机的内存分配而言是坏消息，经常出现大对象会导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间分配给大对象。 将大对象直接在老年代中分配的目的是避免在Eden区和Survivor区之间出现大量内存复制。 4.长期存活的对象进入老年代 虚拟机采用分代收集的思想管理内存，因此需要识别每个对象应该放在新生代还是老年代。虚拟机给每个对象定义了年龄计数器，对象在Eden区出生之后，如果经过第一次Minor GC之后仍然存活，将进入Survivor区，同时对象年龄变为 1，对象在Survivor区每经过一次Minor GC且存活，年龄就增加 1，增加到一定阈值时则进入老年代（阈值默认为 15）。 5.动态对象年龄判定 为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在Survivor区中相同年龄的所有对象的空间总和大于Survivor区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。 6.空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么Minor GC可以确保是安全的。 只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。 ","date":"2021-02-07","objectID":"/posts/java-se-%E6%95%99%E7%A8%8B/:3:0","tags":null,"title":"Java SE 教程","uri":"/posts/java-se-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Python 是现在最受欢迎的语言。 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"dict dict() # {} dict(a=1, b=2, c=3) # {'a': 1, 'b': 2, 'c': 3} dict(zip(['a', 'b', 'c'], [1, 2, 3])) # {'a': 1, 'b': 2, 'c': 3} dict([('a', 1), ('b', 2), ('c', 3)]) # {'a': 1, 'b': 2, 'c': 3} ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Python 内置函数 abs(x) # 返回绝对值。若参数为复数，则返回复数的模。 divmod(a, b) # 返回 tuple(a // b, a % b) input(words) # 打印 words，读取用户输入，返回 str 类型 ord(c) # 返回字符对应的 ASCII 数值，或者 Unicode 数值 chr(i) # 返回整数（0～255，10进制或16进制）对应的 ASCII 字符。 bin(i) # 返回一个整数（int 或 long int）的二进制表示，str 类型。 complex(real=0, image=0) # 复数 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"staticmethod 声明静态方法，即可以不实例化类而直接调用该方法。类中类也可以。 class C(object): @staticmethod def f(arg1, arg2, ...): ... ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:2:1","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"enumerate 将一个可遍历的数据对象（如列表、元组或字符串）组合为一个索引序列，同时列出数据和下标，一般用在 for 循环中。 enumerate(sequence, start=0) list(enumerate([1, 2, 3])) # [(0, 1), (1, 2), (2, 3)] list(enumerate((1, 2, 3))) # [(0, 1), (1, 2), (2, 3)] list(enumerate('abc')) # [(0, 'a'), (1, 'b'), (2, 'c')] list(enumerate('abc', start=1)) # [(1, 'a'), (2, 'b'), (3, 'c')] ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:2:2","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"int 若 x 为数字，返回整数部分。（不能有 base 参数，否则报错） 若 x 为字符串，则将 x 视为 base 进制的数，返回转换为 10 进制后的数。（x 不能为小数或不存在的数，否则报错） int(x, base=10) int() # 0 int(3.9) # 3 int(-3.9) # -3 int('10', 2) # 2 int('0xA', 16) # 10 int('aB', 16) # 171 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:2:3","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"常用内置库 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:3:0","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"random random库 ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:3:1","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"os os模块常用来用来处理文件和目录。 import os os.chdir(path) # 切换目录，相当于 cd os.chmod(path, mode) # 改变文件权限，相当于 chmod os.getcwd() # 返回当前目录绝对路径，相当于 pwd os.listdir(path) # 返回文件夹下所有文件或文件夹的名字的列表，相当于 ls os.open(file, flags[, mode]) # 打开文件，并且设置打开选项 os.mkdir(path[, mode]) # 以权限 mode (int) 创建一个名或路径为 path 的空文件夹，默认 mode 是 0777 (八进制) os.remove(path) # 删除文件，不能删除文件夹 os.rmdir(path) # 删除空文件夹 os.removedirs(path) # 递归删除空文件夹 os.rename(src, dst) # 重命名，原名 src ，改后 dst os.path os.path模块主要用于获取文件的属性。 os.path.exists(path) # 判断路径是否存在 os.path.isdir(path) # 判断路径是否为目录 os.path.abspath(path) # 返回绝对路径 os.path.dirname(path) # 返回文件路径 os.path.basename(path) # 返回文件名 os.path.commonprefix(pathList) # 返回多个路径的公共最长路径 os.path.join(path1[, path2[, ...]]) # 路径合并 # 返回上一级路径 # 'A/B' -\u003e 'A' # 'A' -\u003e '' os.path.dirname(path) # 路径分割，返回 tuple(dirname, basename) # 'A/B/C' -\u003e ('A/B', 'C') os.path.split(path) # 路径分割，返回 tuple(pathname, extension) # 'A/B/C.exe' -\u003e ('A/B/C', '.exe') os.path.splitext(path) ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:3:2","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"文件操作 open() ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:3:3","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"tricks ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:0","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"python 自动给数字前面补 0 的方法 s1 = \"12\" s1.zfill(4) # \"0012\" s2 = \"-12\" s2.zfill(4) # \"-0012\" a = 12 '%04d' % a # \"0012\" ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:4:1","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Q\u0026A ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:0","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"UnicodeDecodeError 问题描述: UnicodeDecodeError: 'gbk' codec can't decode byte 0xad in position 7: illegal multibyte sequence 解决方案: 将open(filename, 'r')改为open(filename, 'r', encoding='utf-8') ","date":"2021-02-06","objectID":"/posts/python-%E6%95%99%E7%A8%8B/:5:1","tags":null,"title":"Python 教程","uri":"/posts/python-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈等。 C++ 标准模板库的核心包括以下三个组件： 容器（Containers）：用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，如 deque、list、vector、map、set、bitset 等。 算法（Algorithms）：对容器执行各种操作，包括初始化、排序、搜索和翻转等。 迭代器（Iterators）：遍历容器。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:0:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cvector\u003e vector是一个动态数组，需要#include \u003cvector\u003e。 数组大小动态改变 可以进行逻辑操作（是否相等、比较大小） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"vector 1.1 初始化 vector() 初始化为空 explicit vector(size_type n) 初始化为 n 个 0 vector(size_type n, const value_type\u0026 val) 初始化为 n 个 val vector(InputIterator first, InputIterator last) 初始化为数组或迭代器 [first, last) 区间内的元素 vector(const vector\u0026 x) 复制 vector 中的元素 vector(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u0026 operator=(const vector\u0026 x) 复制 vector 中的元素 vector\u0026 operator=(initializer_list\u003cvalue_type\u003e il) 复制指定列表中的元素 vector\u003cint\u003e v1; // {} vector\u003cint\u003e v2 = {1, 2, 3}; // {1, 2, 3} vector\u003cint\u003e v3({1, 2, 3}); // {1, 2, 3} vector\u003cint\u003e v4 = v3; // {1, 2, 3} vector\u003cint\u003e v5(v3); // {1, 2, 3} vector\u003cint\u003e v6(3); // {0, 0, 0} vector\u003cint\u003e v7(3, 2); // {2, 2, 2} int arr[] = {1, 2, 3}; vector\u003cint\u003e v8(arr, arr + 1); // {1} vector\u003cint\u003e v9(v4.begin(), v4.begin() + 2); // {1, 2} vector\u003cvector\u003cint\u003e\u003e v10(2, vector\u003cint\u003e(3)); // {{0, 0, 0}, {0, 0, 0}} 类型任意，长度可以是变量 1.2 添加 void push_back(const value_type\u0026 val) 在末尾添加元素 void emplace_back(Args\u0026\u0026... args) 在末尾构造并插入元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 在指定位置构造并插入元素 iterator insert(const_iterator position, const value_type\u0026 val) 在指定位置插入元素 iterator insert(const_iterator position, size_type n, const value_type\u0026 val) 在指定位置插入 n 个 val iterator insert(const_iterator position, InputIterator first, InputIterator last) 在指定位置插入数组或迭代器 [first, last) 区间内的元素 iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il) 在指定位置插入指定列表中的元素 vector\u003cpair\u003cstring, int\u003e\u003e v; v.push_back(make_pair(\"Mike\", 1)); v.emplace_back(\"John\", 2); // 隐式地构造了 pair 并插入末尾 1.3 删除 void pop_back() 删除最后一个元素 iterator erase(const_iterator position) 删除指定位置的元素 iterator erase(const_iterator first, const_iterator last) 删除迭代器 [first, last) 区间内的元素 void clear() noexcept 清空 1.4 容量 bool empty() const 判断容器是否为空 size_type size() const 返回元素个数 size_type capacity() const noexcept 返回已分配存储容量的大小 void resize(size_type n) 改变大小，变小截断，变大补 0 void resize(size_type n, const value_type\u0026 val) 改变大小，变小截断，变大补 val 1.5 其他操作 void assign(size_type n, const value_type\u0026 val) 赋值为 n 个 val void assign(InputIterator first, InputIterator last) 赋值为数组或迭代器 [first, last) 区间内的元素 void assign(initializer_list\u003cvalue_type\u003e il) 赋值为指定列表中的元素 void swap(vector\u0026 x) 交换两个 vector 1.6 遍历 reference operator[](size_type n) 返回位置为 n 的元素的引用，越界发生未知错误（不推荐） reference at(size_type n) 返回位置为 n 的元素的引用，越界抛出 out_of_range 异常（推荐） reference front() 返回第一个元素的引用 reference back() 返回最后一个元素的引用 for (auto it = v.begin(); it != v.end(); it++) {*it;} // 正向遍历，有迭代器 for (auto it = v.rbegin(); it != v.rend(); it++) {*it;} // 反向遍历，有迭代器 for (int\u0026 e : v) {e;} // 正向遍历，无索引 for (int e : v) {e;} // 正向遍历，无索引，不改变原数据 for (int i = 0; i \u003c v.size(); i++) {v.at(i);} // 正向遍历，有索引 for (int i = v.size() - 1; i \u003e= 0; i--) {v.at(i);} // 反向遍历，有索引 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"vector\u003cbool\u003e 基本操作同 vector。 特殊操作： void flip() noexcept 所有位都翻转 static void swap(reference ref1, reference ref2) noexcept 交换两个位置的值 vector\u003cbool\u003e mask; mask.push_back(true); mask.push_back(false); // {1 0} mask.flip(); // {0 1} mask.swap(mask[0], mask[1]); // {1 0} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:1:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cstack\u003e stack是一个栈，需要#include \u003cstack\u003e。 后进先出（LIFO） ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"2.1 初始化 默认底层容器是 deque 可以显式设置底层容器为 vector stack\u003cint\u003e st1; stack\u003cint\u003e st2(st1); stack\u003cint\u003e st3({1, 2, 3}); // st3.top() == 3 deque\u003cint\u003e dq(2, 3); stack\u003cint\u003e st4(dq); // 默认底层容器是 deque vector\u003cint\u003e v({1, 2, 3}); stack\u003cint, vector\u003cint\u003e\u003e st5(v); // 设置底层容器为 vector ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"2.2 操作 void push(const value_type\u0026 val) 栈顶添加元素 void emplace(Args\u0026\u0026... args) 栈顶添加元素 void pop() 栈顶弹出元素 reference\u0026 top() 返回栈顶元素 bool empty() const 判断栈是否为空 size_type size() const 返回元素个数 void swap(stack\u0026 x) noexcept 交换两个栈 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:2:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003clist\u003e list是一个双向链表，需要#include \u003clist\u003e。 无法按索引访问元素 插入删除元素效率高 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"3.1 基本操作 基本操作同 vector。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"3.2 特殊操作 添加： void push_front(const value_type\u0026 val) 在开头插入元素 void emplace_front(Args\u0026\u0026... args) 在开头构造并插入元素 void splice(const_iterator position, list\u0026 x) 将 x 中的元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator i) 将 x 中的位置为 i 元素转移到指定位置 void splice(const_iterator position, list\u0026 x, const_iterator first, const_iterator last) 将 x 中的 [first, last) 区间内的元素转移到指定位置 void merge(list\u0026 x) void merge(list\u0026 x, Compare comp) 删除： void pop_front() 删除第一个元素 void remove(const value_type\u0026 val) 删除值为 val 的所有元素 void remove_if(Predicate pred) 删除满足自定义一元函数的元素 void unique() 删除连续重复元素，只保留一个 void unique(BinaryPredicate binary_pred) 删除满足自定义二元函数的元素 其他： void sort() 按升序排序 void sort(Compare comp) 按自定义二元函数排序 void reverse() noexcept 逆序 list\u003cint\u003e l = {1, 1, 1, 2, 1, 2}; l.unique(); // {1, 2, 1, 2} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:3:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cqueue\u003e queue是一个单向队列容器，需要#include \u003clist\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"queue 先进先出（FIFO） 队尾添加，队首删除 4.1.1 初始化 queue\u003cint\u003e q1; // 空 queue queue\u003cint\u003e q2(5, 2); // 大小为 5 的 queue，值均为 2 queue\u003cint\u003e q3(q2); // 复制 queue int arr[] = {1, 2, 3}; queue\u003cint\u003e q4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; queue\u003cint\u003e q5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 queue\u003cint\u003e q6(v); // 复制 vector 4.1.2 操作 void push(const value_type\u0026 val) 队尾添加元素 void emplace(Args\u0026\u0026... args) 队尾添加元素 void pop() 删除队首元素 const_reference\u0026 front() const 返回队首元素 const_reference\u0026 back() const 返回队尾元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"priority_queue 优先队列（堆） 默认最大优先队列（最大堆） 自动调整顺序使队首（堆顶）元素最大 4.2.1 初始化 priority_queue\u003cint\u003e pq1; // 空 priority_queue priority_queue\u003cint\u003e pq2(5, 2); // 大小为 5 的 priority_queue，值均为 2 priority_queue\u003cint\u003e pq3(pq2); // 复制 priority_queue int arr[] = {1, 2, 3}; priority_queue\u003cint\u003e pq4(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; priority_queue\u003cint\u003e pq5(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 priority_queue\u003cint\u003e pq6(v); // 复制 vector priority_queue\u003cint, vector\u003cint\u003e, less\u003cint\u003e\u003e pq7; // 最大优先队列（最大堆） priority_queue\u003cint, vector\u003cint\u003e, greater\u003cint\u003e\u003e pq8; // 最小优先队列（最小堆） 4.2.2 操作 void push(const value_type\u0026 val) 添加元素 void emplace(Args\u0026\u0026... args) 添加元素 void pop() 删除队首（堆顶）元素 const_reference top() const 返回队首（堆顶）元素 size_type size() const 返回大小 bool empty() const 是否为空 void swap(priority_queue\u0026 x) noexcept 交换 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:4:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cdeque\u003e deque是一个双端队列容器，需要#include \u003cdeque\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"5.1 初始化 deque\u003cint\u003e dq1; // 空 deque deque\u003cint\u003e dq2(5, 2); // 大小为 5 的 deque，值均为 2 deque\u003cint\u003e dq3(dq2); // 复制 deque deque\u003cint\u003e dq4(dq2.begin(), dq2.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 int arr[] = {1, 2, 3}; deque\u003cint\u003e dq5(arr, arr + 1); // 复制数组 [first, last) 区间内的元素 vector\u003cint\u003e v = {1, 2, 3}; deque\u003cint\u003e dq6(v.begin(), v.begin() + 1); // 复制迭代器 [first, last) 区间内的元素 deque\u003cint\u003e dq7 = dq6; deque\u003cint\u003e dq8 = {1, 2, 3}; ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"5.2 修改 void push_back(const value_type\u0026 val) 队尾添加元素 void push_front(const value_type\u0026 val) 队首添加元素 void emplace_back(Args\u0026\u0026... args) 队尾添加元素 void emplace_front(Args\u0026\u0026... args) 队首添加元素 iterator emplace(const_iterator position, Args\u0026\u0026... args) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, const value_type\u0026 val) 迭代器指定位置前面添加元素 iterator insert(const_iterator position, size_type n, const value_type\u0026 val) 迭代器指定位置前面添加 n 个相同元素 iterator insert(const_iterator position, InputIterator first, InputIterator last) 迭代器指定位置前面添加 [first, last) 区间内元素 iterator insert(const_iterator position, initializer_list\u003cvalue_type\u003e il) void pop_back() 删除队尾 void pop_front() 删除队首 iterator erase(iterator position) 删除迭代器指向元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 区间内元素 void clear() noexcept 清空 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"5.3 遍历 deque\u003cint\u003e dq; for (auto it = dq.begin(); it != dq.end(); it++) {*it;} for (auto it = dq.rbegin(); it != dq.rend(); it++) {*it;} for (int e : dq) {e;} for (int\u0026 e : dq) {e;} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:3","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"5.4 操作 size_type size() const noexcept 返回大小 void resize(size_type n) 调整大小为 n，调大补 0，调小末尾截断 void resize(size_type n, const value_type\u0026 val) 调整大小为 n，调大补 val，调小末尾截断 bool empty() const noexcept 判断是否为空 reference operator[](size_type n) 访问指定位置元素，越界报错 reference at(size_type n) 访问指定位置元素，越界抛出 out_of_range 异常 const_reference back() const 返回队尾元素 const_reference front() const 返回队首元素 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:5:4","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cmap\u003e map是一个有序键值对容器，每个元素由关键字（key）和该关键字对应的值（value）组合而成。需要#include \u003cmap\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"map key唯一且无法修改 默认按key升序排列 底层二叉搜索树实现，速度比unordered_map慢 6.1 初始化 map\u003cchar, int\u003e m1; map\u003cchar, int\u003e m2(m1); map\u003cchar, int\u003e m3(m1.begin(), m1.end()); map\u003cchar, int, less\u003cchar\u003e\u003e m4; // 按 key 升序排列，相当于 map\u003cchar, int\u003e map\u003cchar, int, greater\u003cchar\u003e\u003e m5; // 按 key 降序排列 6.2 添加 map\u003cchar, int\u003e m1, m2; m1['a'] = 1; m1.insert(make_pair('b', 2)); m1.insert(pair\u003cchar, int\u003e('c', 3)); m1.emplace('d', 4); m2.insert(m1.begin(), m1.find('c')); 6.3 删除 map\u003cchar, int\u003e m; m['a'] = 1; m['b'] = 2; m['c'] = 3; m.erase(m.find('c')); m.erase('a'); m.erase(m.begin(), m.end()); m.clear(); 6.4 遍历 mapped_type\u0026 operator[](const key_type\u0026 k) mapped_type\u0026 at(const key_type\u0026 k) for (auto it = m.begin(); it != m.end(); it++) { it-\u003efirst; it-\u003esecond; } for (auto it = m.rbegin(); it != m.rend(); it++) { it-\u003efirst; it-\u003esecond; } for (auto \u0026p : m) { p.first; p.second; } 6.5 其他操作 size_type size() const noexcept 返回元素个数 bool empty() const noexcept 判断是否为空 void swap(map\u0026 x) 交换两个 map iterator find(const key_type\u0026 k) 查找 key 值为 k 的元素，未找到返回 map::end() size_type count(const key_type\u0026 k) const 返回 key 值为 k 的元素的数量，由于 key 唯一，则存在返回 1，不存在返回 0 iterator lower_bound(const key_type\u0026 k) 返回指向第一个 key 大于等于 k 的元素的迭代器 iterator upper_bound(const key_type\u0026 k) 返回指向第一个 key 大于 k 的元素的迭代器 pair\u003citerator, iterator\u003e equal_range(const key_type\u0026 k) 返回指向 key 等于 k 的所有元素的范围的边界元素的迭代器 [first, second) map\u003cchar, int\u003e m; m['a'] = 0; m.find('b'); // m.end() m.count('a'); // 1 m.count('b'); // 0 6.6 排序 map没有随机迭代器，只有顺序迭代器，所以不能用sort 6.6.1 按 key 排序 key 升序，value 随机 默认情况，map\u003cint, char\u003e，相当于map\u003cint, char, less\u003cint\u003e\u003e。 当 key 为自定义类时： typedef struct { // 自定义类 int one, two; } Grade; struct Cmp { // 自定义比较类 bool operator()(const Grade\u0026 a, const Grade\u0026 b) const { if (a.one != b.one) return a.one \u003c b.one; return a.two \u003c b.two; } }; map\u003cGrade, int, Cmp\u003e m; typedef struct { // 自定义类 int one, two; } Grade; struct Cmp { // 自定义比较类 bool operator()(const Grade\u0026 a, const Grade\u0026 b) const { if (a.one != b.one) return a.one \u003c b.one; return a.two \u003c b.two; } }; map\u003cGrade, int, Cmp\u003e m; key 降序，value 随机 map\u003cint, char, greater\u003cint\u003e\u003e 6.6.2 按 value 排序 key 降序，value 随机 key 降序，value 随机 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"multimap key允许重复 默认按key升序排列 底层二叉搜索树实现，速度比unordered_multimap慢 基本使用方法同 map。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:6:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cunordered_map\u003e ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"unordered_map key唯一且不能修改，可以添加或删除 无序 速度比map快 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"unordered_multimap ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:7:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cset\u003e set是一个有序集合容器。需要#include \u003cset\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"set 元素唯一 元素默认升序 底层二叉排序树实现，速度比unordered_set慢 初始化 set\u003cint\u003e s1; // {} set\u003cint\u003e s2 = {1, 2, 3}; // { 1 2 3 } set\u003cint\u003e s3 = s2; // { 1 2 3 } set\u003cint\u003e s4({1, 2, 3}); // { 1 2 3 } int arr[] = {1, 2, 3}; set\u003cint\u003e s5(arr, arr + 3); // { 1 2 3 } set\u003cint\u003e s6(arr, arr + 1); // { 1 } set\u003cint\u003e s7(s4); // { 1 2 3 } set\u003cint\u003e s8(s4.begin(), s4.end()); // { 1 2 3 } set\u003cint\u003e s9(s4.begin(), s4.begin() + 1); // { 1 } struct CompClass { bool operator() (const int\u0026 left, const int\u0026 right) const { return left \u003c right; } }; set\u003cint, CompClass\u003e s10; // { 1 2 3 } 修改 pair\u003citerator, bool\u003e emplace(Args\u0026\u0026... args) 添加一个元素 pair\u003citerator, bool\u003e insert(value_type\u0026\u0026 val) 添加一个元素 void insert(InputIterator first, InputIterator last) 添加 [first, last) 范围内的元素 void insert(initializer_list\u003cvalue_type\u003e il) 添加另一个容器的所有元素 iterator erase(const_iterator position) 删除指定位置元素 size_type erase(const value_type\u0026 val) 删除指定元素 iterator erase(const_iterator first, const_iterator last) 删除 [first, last) 范围内的元素 void swap(set\u0026 x) 交换两个 set void clear() noexcept 清空 容量 bool empty() const noexcept 判断是否为空 size_type size() const noexcept 当前元素个数 遍历 for (auto it = s.begin(); it != s.end(); it++) {*it;} for (auto it = s.rbegin(); it != s.rend(); it++) {*it;} for (int e : s) {e;} for (int\u0026 e : s) {e;} 操作 iterator find(const value_type\u0026 val) 查找指定元素，成功返回迭代器，失败返回 end() size_type count(const value_type\u0026 val) const 返回指定元素的个数 iterator lower_bound(const value_type\u0026 val) 下界，查找第1个大于等于指定元素的位置，成功返回迭代器，失败返回 end() iterator upper_bound(const value_type\u0026 val) 上界，查找最后一个小于等于指定元素的位置，成功返回迭代器，失败返回 end() pair\u003citerator, iterator\u003e equal_range(const value_type\u0026 val) 返回 set 中与指定元素相等的一个范围 [first, second) ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"multiset 允许重复元素 元素默认升序 速度比unordered_set慢 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:8:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cunordered_set\u003e unordered_set是一个无序集合容器。需要#include \u003cunordered_set\u003e。 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"unordered_set 元素唯一 无序 底层哈希表实现，速度比set快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"unordered_multiset 允许重复元素 无序 速度比multiset快 使用方法同set ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:9:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003cbitset\u003e bitset模拟一个 bool 数组，每个元素只能是 0 或 1. ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"初始化 bitset\u003c4\u003e b1; // 0000 bitset\u003c4\u003e b2(\"100\"); // 0100, b2[0] == 0 bitset\u003c4\u003e b3(\"1100\"); // 1100 bitset\u003c4\u003e b4(\"11100\"); // 1110 bitset\u003c4\u003e b5(b2); // 0100 string s = \"1010\"; bitset\u003c4\u003e b6(s); // 1010 ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"位运算 bitset\u003c4\u003e a(\"1001\"), b(\"1010\"); a \u0026 b; // 1000 AND a | b; // 1011 OR a ^ b; // 0011 XOR ~a; // 0110 NOT a \u003c\u003c 1; // 0010 SHL a \u003e\u003e 1; // 0100 SHR a == b; // false a != b; // true ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"操作 reference operator[](size_t pos) 访问指定位置，0 是最右边一位，即最低位 size_t count() const noexcept 返回 1 的 个数 size_t size() const noexcept 返回长度 bool test(size_t pos) const 判断指定位置是否为 1 bool any() const noexcept 判断是否存在某一位是 1 bool none() const noexcept 判断是否全是 0 bool all() const noexcept 判断是否全是 1 bitset\u0026 set() noexcept 全部置为 1 bitset\u0026 set(size_t pos, bool val = true) 指定位置置为 1 bitset\u0026 reset() noexcept 全部置为 0 bitset\u0026 reset(size_t pos) 指定位置置为 0 bitset\u0026 flip() noexcept 翻转 bitset\u0026 flip(size_t pos) 翻转指定位置 string to_string() const 返回该二进制数的字符串 unsigned long to_ulong() const 返回该 2 进制数对应的整数，类型 unsigned long unsigned long long to_ullong() const 返回该 2 进制数对应的整数，类型 unsigned long long ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:10:3","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003calgorithm\u003e ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"sort 数组排序 bool cmp(int a, int b) { return a \u003e b; } // 自定义降序比较函数 int arr[] = {2, 3, 1}; sort(arr, arr + 3); // {1, 2, 3} sort(arr, arr + 3, cmp); // {3, 2, 1} vector\u003cint\u003e v(arr, arr + 3); sort(v.begin(), v.end()); // {1, 2, 3} sort(v.begin(), v.end(), cmp); // {3, 2, 1} 类（结构体）排序 class Stu { // 自定义类 public: int no; int score; }; bool cmpClass(Stu\u0026 a, Stu\u0026 b) { // 自定义类的降序比较函数 return a.score \u003e b.score; } Stu stu[] = {1, 90, 2, 100, 3, 80}; // {{1, 90}, {2, 100}, {3, 80}} sort(stu, stu + 3, cmpClass); // {{2, 100}, {1, 90}, {3, 80}} ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:1","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"reverse ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:2","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"lower_bound ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:3","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"upper_bound ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:4","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"search ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:11:5","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"\u003ctuple\u003e tuple将不同类型的许多元素打包成一个对象，便于访问，（就像定义了一个只有属性的类，并且属性只定义了类型，未定义名字）。需要#include \u003ctuple\u003e。 元素类型任意 元素数量任意 tuple\u003cint, string\u003e t1; tuple\u003cint, string\u003e t2{t1}; tuple\u003cint, string\u003e t3(t2); tuple\u003cint, string\u003e t4{1, \"one\"}; get\u003c0\u003e(t4); // 1 get\u003c1\u003e(t4); // one get\u003cint\u003e(t4); // 1 get\u003cstring\u003e(t4); // one make_tuple(2, string(\"two\")); ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:12:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":["C++"],"content":"参考 Standard C++ Library Reference - cplusplus.com ","date":"2021-02-06","objectID":"/posts/c++-stl-%E6%95%99%E7%A8%8B/:13:0","tags":["C++"],"title":"C++ STL 教程","uri":"/posts/c++-stl-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"Windows 终端是一个面向命令行工具和 shell（如命令提示符、PowerShell 和适用于 Linux 的 Windows 子系统 (WSL)）用户的新式终端应用程序。 它的主要功能包括多个选项卡、窗格、Unicode 和 UTF-8 字符支持、GPU 加速文本呈现引擎，你还可用它来创建你自己的主题并自定义文本、颜色、背景和快捷方式。 ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"一、安装 推荐从 Microsoft Store 安装，也可从 官方Github 下载安装。 ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"二、自定义配色方案 打开 Windows Terminal，点击当前标签页顶端右侧向下的箭头，出现下拉菜单，点击设置。 Ctrl + Alt + , (逗号) ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"三、自定义背景 ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:3:0","tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"四、命令行参数 使用三个窗格从 PowerShell 打开 Windows 终端（左窗格运行命令提示符配置文件，右窗格拆分为两个，上面用于 PowerShell，下面用于命令提示符）： wt -p cmd `; split-pane -p powershell `; split-pane -H cmd ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:4:0","tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"参考文章 新生代 Windows 终端：Windows Terminal 的全面自定义 - 少数派 Windows 终端 - Microsoft ","date":"2021-02-04","objectID":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/:5:0","tags":null,"title":"Windows Terminal 教程","uri":"/posts/windows-terminal-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"PowerShell 所有指令或参数均不区分大小写！ ","date":"2021-02-04","objectID":"/posts/powershell-%E6%95%99%E7%A8%8B/:0:0","tags":null,"title":"PowerShell 教程","uri":"/posts/powershell-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"帮助 help | Get-Help [[-Name] \u003cstring\u003e] # 本地查询某命令的用法 [-Online] # 微软官方文档查询某命令的用法 ","date":"2021-02-04","objectID":"/posts/powershell-%E6%95%99%E7%A8%8B/:1:0","tags":null,"title":"PowerShell 教程","uri":"/posts/powershell-%E6%95%99%E7%A8%8B/"},{"categories":null,"content":"查看目录 ls | dir | gci | Get-ChildItem [[-Path] \u003cstring[]\u003e] # [[-Filter] \u003cstring\u003e] [-Include \u003cstring[]\u003e] [-Exclude \u003cstring[]\u003e] [-Recurse] # 递归列出文件夹中内容 [-Depth \u003cuint32\u003e] # 限制递归层数 [-Force] [-Name] [-Attributes \u003cFlagsExpression[FileAttributes]\u003e] [-FollowSymlink] [-Directory] [-File] [-Hidden] [-ReadOnly] [-System] [\u003cCommonParameters\u003e] 文件属性：[d]^(directory), a(archive), r(read-only), h(hidden), l(link), ","date":"2021-02-04","objectID":"/posts/powershell-%E6%95%99%E7%A8%8B/:2:0","tags":null,"title":"PowerShell 教程","uri":"/posts/powershell-%E6%95%99%E7%A8%8B/"},{"categories":["Hugo"],"content":"Windows 10 下用 Hugo 的 LoveIt 主题搭建一个博客，并使用 Github Action 自动发布到 Github Pages。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:0:0","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"一、安装 Github 下载hugo_extended_0.XX.X_Windows-64bit.zip，解压并添加到系统环境变量，在命令行输入hugo version，若出现如下内容即为配置成功。 hugo v0.81.0-59D15C97+extended windows/amd64 BuildDate=2021-02-19T17:07:12Z VendorInfo=gohugoio Git 官网下载安装。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:1:0","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"二、创建网站 hugo new site quickstart cd quickstart git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:2:0","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"三、添加内容 hugo new posts/My-First-Blog.md 打开刚创建的文件，显示如下： --- title: \"My First Blog\" date: 2021-02-04T16:18:47+08:00 draft: true --- 所有页面均作为草稿创建。文章完成后，如果想要渲染这些页面，请修改为draft: false。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:0","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"3.1 文章中添加图片 Hugo 的配置文件和文章中引用图片都是以static文件夹作为根目录的。也就是说文章中插入/xxx/yyy.jpg，实际图片位置是/static/xxx/yyy.jpg。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:3:1","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"四、本地部署 以渲染草稿的形式本地部署，命令行在网站根目录下输入（若不想显示草稿内容，去掉-D）： hugo server -D 输出如下内容： Start building sites … WARN 2021/02/04 16:18:50 Current environment is \"development\". The \"comment system\", \"CDN\" and \"fingerprint\" will be disabled. 当前运行环境是 \"development\". \"评论系统\", \"CDN\" 和 \"fingerprint\" 不会启用. | ZH-CN -------------------+-------- Pages | 11 Paginator pages | 0 Non-page files | 0 Static files | 83 Processed images | 0 Aliases | 2 Sitemaps | 1 Cleaned | 0 Built in 160 ms Watching for changes in C:\\Users\\backs\\Downloads\\docs\\quickstart\\{archetypes,content,data,layouts,static,themes} Watching for config changes in C:\\Users\\backs\\Downloads\\docs\\quickstart\\config.toml Environment: \"development\" Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 浏览器打开 http://localhost:1313/ 即可看到部署在本地的网站。 网站部署后，当配置或文件内容发生更改时，页面会自动刷新。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:4:0","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"五、主题自定义 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:0","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"简单配置 编辑quickstart根目录下的config.toml文件，内容如下： # 域名 baseURL = \"https://backsided.github.io\" # 默认语言 [en, zh-cn, ...] defaultContentLanguage = \"zh-cn\" # 语言 languageCode = \"zh-CN\" # 是否包括中日韩文字 hasCJKLanguage = true # 标题 title = \"Backsided's World\" # 主题 theme = \"LoveIt\" [params] # 主题版本 version = \"0.2.X\" # 网站描述 description = \"这是Backsided的博客\" # 作者配置 [author] name = \"Backsided\" email = \"\" link = \"\" [menu] [[menu.main]] identifier = \"posts\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" name = \"文章\" url = \"/posts/\" # 当你将鼠标悬停在此菜单链接上时, 将显示的标题 title = \"\" weight = 1 [[menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 # Hugo 解析文档的配置 [markup] # 语法高亮设置 (https://gohugo.io/content-management/syntax-highlighting) [markup.highlight] # false 是必要的设置 (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:1","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"高级配置（可选） ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:2","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[params] [params] # 主题版本 version = \"0.2.X\" # 描述 description = \"这是Backsided的博客\" # 关键词 keywords = [\"Theme\", \"Hugo\"] # 网站默认主题样式 (\"light\", \"dark\", \"auto\") defaultTheme = \"auto\" # 公共 git 仓库路径，仅在 enableGitInfo 设为 true 时有效 gitRepo = \"\" # 选择哈希函数用来 SRI, 为空时表示不使用 SRI # (\"sha256\", \"sha384\", \"sha512\", \"md5\") fingerprint = \"\" # 日期格式 dateFormat = \"2006-01-02\" # 网站图片, 用于 Open Graph 和 Twitter Cards images = [\"/logo.png\"] [params.app] # 应用图标配置 [params.app] # 当添加到 iOS 主屏幕或者 Android 启动器时的标题, 覆盖默认标题 title = \"LoveIt\" # 是否隐藏网站图标资源链接 noFavicon = false # 更现代的 SVG 网站图标, 可替代旧的 .png 和 .ico 文件 svgFavicon = \"\" # Android 浏览器主题色 themeColor = \"#ffffff\" # Safari 图标颜色 iconColor = \"#5bbad5\" # Windows v8-10磁贴颜色 tileColor = \"#da532c\" [params.search] # 搜索配置 [params.search] enable = true # 搜索引擎的类型 (\"lunr\", \"algolia\") type = \"lunr\" # 文章内容最长索引长度 contentLength = 4000 # 搜索框的占位提示语 placeholder = \"\" # 最大结果数目 maxResultLength = 10 # 结果内容片段长度 snippetLength = 50 # 搜索结果中高亮部分的 HTML 标签 highlightTag = \"em\" # 是否在搜索索引中使用基于 baseURL 的绝对路径 absoluteURL = false [params.search.algolia] index = \"\" appID = \"\" searchKey = \"\" [params.header] # 页面头部导航栏配置 [params.header] # 桌面端导航栏模式 (\"fixed\", \"normal\", \"auto\") desktopMode = \"fixed\" # 移动端导航栏模式 (\"fixed\", \"normal\", \"auto\") mobileMode = \"auto\" # 页面头部导航栏标题配置 [params.header.title] # LOGO 的 URL logo = \"\" # 标题名称 name = \"Backsided's World\" # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \"\" # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \"\" # 是否为标题显示打字机动画 typeit = true [params.footer] # 页面底部信息配置 [params.footer] enable = true # 自定义内容 (支持 HTML 格式) custom = '' # 是否显示 Hugo 和主题信息 hugo = true # 是否显示版权信息 copyright = true # 是否显示作者 author = true # 网站创立年份 since = 2021 # ICP 备案信息，仅在中国使用 (支持 HTML 格式) icp = \"\" # 许可协议信息 (支持 HTML 格式) license = '\u003ca rel=\"license external nofollow noopener noreffer\" href=\"https://creativecommons.org/licenses/by-nc/4.0/\" target=\"_blank\"\u003eCC BY-NC 4.0\u003c/a\u003e' [params.section] # Section (所有文章) 页面配置 [params.section] # section 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.list] # List (目录或标签) 页面配置 [params.list] # list 页面每页显示文章数量 paginate = 20 # 日期格式 (月和日) dateFormat = \"01-02\" # RSS 文章数目 rss = 10 [params.home] # 主页配置 [params.home] # RSS 文章数目 rss = 10 # 主页个人信息 [params.home.profile] enable = true # Gravatar 邮箱，用于优先在主页显示的头像 gravatarEmail = \"\" # 主页显示头像的 URL avatarURL = \"/images/avatar.png\" # 主页显示的网站标题 (支持 HTML 格式) title = \"\" # 主页显示的网站副标题 subtitle = \"这是我的全新 Hugo 网站\" # 是否为副标题显示打字机动画 typeit = true # 是否显示社交账号 social = true # 免责声明 (支持 HTML 格式) disclaimer = \"\" # 主页文章列表 [params.home.posts] enable = true # 主页每页显示文章数量 paginate = 6 [params.social] # 作者的社交信息设置 [params.social] GitHub = \"xxxx\" Linkedin = \"\" Twitter = \"xxxx\" Instagram = \"xxxx\" Facebook = \"xxxx\" Telegram = \"xxxx\" Medium = \"\" Gitlab = \"\" Youtubelegacy = \"\" Youtubecustom = \"\" Youtubechannel = \"\" Tumblr = \"\" Quora = \"\" Keybase = \"\" Pinterest = \"\" Reddit = \"\" Codepen = \"\" FreeCodeCamp = \"\" Bitbucket = \"\" Stackoverflow = \"\" Weibo = \"\" Odnoklassniki = \"\" VK = \"\" Flickr = \"\" Xing = \"\" Snapchat = \"\" Soundcloud = \"\" Spotify = \"\" Bandcamp = \"\" Paypal = \"\" Fivehundredpx = \"\" Mix = \"\" Goodreads = \"\" Lastfm = \"\" Foursquare = \"\" Hackernews = \"\" Kickstarter = \"\" Patreon = \"\" Steam = \"\" Twitch = \"\" Strava = \"\" Skype = \"\" Whatsapp = \"\" Zhihu = \"\" Douban = \"\" Angellist = \"\" Slidershare = \"\" Jsfiddle = \"\" Deviantart = \"\" Behance = \"\" Dribbble = \"\" Wordpress = \"\" Vine = \"\" Googlescholar = \"\" Researchgate = \"\" Mastodon = \"\" Thingiverse = \"\" Devto = \"\" Gitea = \"\" XMPP = \"\" Matrix = \"\" Bilibili = \"\" Email = \"xxxx@xxxx.com\" RSS = true [params.page] # 文章页面配置 [params.page] # 是否在主页隐藏一篇文章 hiddenFromHomePage = false # 是否在搜索结果中隐藏一篇文章 hiddenFromSearch = false # 是否使用 twemoji twemoji = false # 是否使用 lightgallery lightgallery = false # 是否使用 ruby 扩展语法 ruby = true # 是否使用 fraction 扩展语法 fraction = true # 是否使用 fontawesome 扩展语法 fontawesome = true # 是否在文章页面显示原始 Markdown 文档链接 linkToMarkdown = true # 是否在 RSS 中显示全文内容 rssFullText = false [params.page.toc] # 目录配置 [params.page.toc] # 是否使用目录 enable = true # 是否保持使用文章前","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:3","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[markup] # Hugo 解析文档的配置 [markup] # 语法高亮设置 [markup.highlight] codeFences = true guessSyntax = true lineNos = true lineNumbersInTable = true # false 是必要的设置 # (https://github.com/dillonzq/LoveIt/issues/158) noClasses = false # Goldmark 是 Hugo 0.60 以来的默认 Markdown 解析库 [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.renderer] # 是否在文档中直接使用 HTML 标签 unsafe = true # 目录设置 [markup.tableOfContents] startLevel = 2 endLevel = 6 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:4","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[author] # 作者配置 [author] name = \"xxxx\" email = \"\" link = \"\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:5","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[sitemap] # 网站地图配置 [sitemap] changefreq = \"weekly\" filename = \"sitemap.xml\" priority = 0.5 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:6","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[Permalinks] # Permalinks 配置 [Permalinks] # posts = \":year/:month/:filename\" posts = \":filename\" ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:7","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[privacy] # 隐私信息配置 [privacy] [privacy.twitter] enableDNT = true [privacy.youtube] privacyEnhanced = true ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:8","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[mediaTypes] # 用于输出 Markdown 格式文档的设置 [mediaTypes] [mediaTypes.\"text/plain\"] suffixes = [\"md\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:9","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[outputFormats.MarkDown] # 用于输出 Markdown 格式文档的设置 [outputFormats.MarkDown] mediaType = \"text/plain\" isPlainText = true isHTML = false ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:10","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"[outputs] # 用于 Hugo 输出文档的设置 [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] page = [\"HTML\", \"MarkDown\"] section = [\"HTML\", \"RSS\"] taxonomy = [\"HTML\", \"RSS\"] taxonomyTerm = [\"HTML\"] ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:5:11","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"六、发布 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:0","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"静态页面发布 hugo 渲染后的静态页面在 public 文件夹中，可将该文件夹中的内容发布。 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:1","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"Github Pages 发布 在 Github 新建两个仓库，\u003cUSERNAME\u003e.github.io.sources 存放内容，\u003cUSERNAME\u003e.github.io 部署页面。其中，存放内容的仓库可以设为私人，也可随意命名。 git remote add origin https://github.com/backsided/backsided.github.io.data.git git add --all git commit -m \"init blog\" git push --set-upstream origin master -f 进入 Github 仓库，点击Actions-\u003eNew workflow-\u003eset up a workflow yourself。 name:Hugo Deploy # 名称随意修改on:push:branches:[master ] # 修改为你当前分支jobs:build:runs-on:ubuntu-latest # 指定系统版本steps:- uses:actions/checkout@v2 # 克隆仓库with:submodules:true# 启用子模块fetch-depth:1- name:Setup Hugo # 安装 hugouses:peaceiris/actions-hugo@v2with:hugo-version:'latest'# 指定 hugo 版本- name:Build Hugo # hugo 生成网站run:hugo- name:Deploy Hugo # 部署网站uses:peaceiris/actions-gh-pages@v3with:personal_token:${{ secrets.ACCESS_TOKEN }} # 与 secrets 里的 token 名称对应external_repository:backsided/backsided.github.io # 指定发布的仓库publish_branch:master # 指定发布仓库的分支publish_dir:./public # 指定要发布的目录 ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:6:2","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"全局详细配置 # 域名 baseURL = \"\" # 构建时包含草稿 buildDrafts = false # 内容文件夹 contentDir = \"content\" # 数据文件夹 dataDir = \"data\" # 内容默认语言（中文：zh-cn） defaultContentLanguage = \"en\" # 根目录跳转到默认语言目录 defaultContentLanguageInSubdir = false # 禁用指定类型页面：page, home, section, taxonomy, term, RSS, sitemap, robotsTXT, 404 disableKinds = [] # 禁用实时重载 disableLiveReload = false # 禁用将 url/path 转小写字母 disablePathToLower = false # 启用 Emoji enableEmoji = false # 使用文件的最后 git 提交日期更新 Lastmod 参数 enableGitInfo = false # 启用 inline shortcode enableInlineShortcodes = false # 是否生成 robots.txt 文件 enableRobotsTXT = false # 日期设置 [frontmatter] # 脚注锚的前缀 footnoteAnchorPrefix = \"\" # 脚注返回链接显示的文本 footnoteReturnLinkContents = \"\" # Google Analytics 跟踪 ID googleAnalytics = \"\" # 自动检测内容中的中文/日文/韩文 hasCJKLanguage = false # 图片设置 [imaging] # 语言设置 [languages] # 启用日志 log = false # 日志保存目录 logFile = \"\" # 主题设置 [markup] # 目录设置 [menu] # 最小化构建设置 [minify] # 模块设置 [module] # 每页的默认文章数量 paginate = 10 # 固定链接 [permalinks] # 生成静态网页的目录 publishDir = \"public\" # 相关设置 [related] # 网站地图设置 [sitemap] # 静态文件目录设置 staticDir = \"static\" # 分类设置 [taxonomies] # 主题 theme = \"\" # 主题目录 themesDir = \"themes\" # 标题 title = \"\" 参考：Configure Hugo ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:7:0","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":["Hugo"],"content":"参考 Quick Start - Hugo Host on GitHub - Hugo Hugo Themes - Hugo LoveIt Theme | Hugo - Github 主题文档 - 基本概念 - LoveIt How to Create Your First Hugo Blog: a Practical Guide - freeCodeCamp 创建 GitHub Pages 站点 - Github 使用Hugo和GitHub搭建博客 - Félix | Medium ","date":"2021-02-04","objectID":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/:8:0","tags":["Hugo"],"title":"Hugo 博客搭建","uri":"/posts/hugo-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"categories":null,"content":"Markdown 是一种轻量级的「标记语言」，易读易写，简洁至上，被广泛使用。 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"一、标题 # 一级标题 h1 ## 二级标题 h2 ### 三级标题 h3 #### 四级标题 h4 ##### 五级标题 h5 ###### 六级标题 h6 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:1:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"二、强调 **加粗** *斜体* ~~删除线~~ ***斜体加粗*** ~~**删除线加粗**~~ ~~*斜体删除线*~~ ~~***斜体删除线加粗***~~ 加粗、斜体、删除线、斜体加粗、删除线加粗、斜体删除线、斜体删除线加粗 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:2:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"三、引用 \u003e 引用 \u003e\u003e 嵌套引用 引用 嵌套引用 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:3:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"四、分割线 --- *** ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:4:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"五、图片 ![Backsided's World](https://backsided.github.io/apple-touch-icon.png \"Backsided's World\") \u003cimg src=\"https://backsided.github.io/apple-touch-icon.png\" alt=\"Backsided's World\" width=\"30%\" height=\"30%\"\u003e Backsided's WorldBacksided\u0026rsquo;s World \" Backsided's World ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:5:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"六、超链接 [Backsided's World](https://backsided.github.io/) Backsided’s World ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:6:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"七、列表 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"无序列表 - 北京 - 上海 - 广州 - 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:1","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"有序列表 1. 北京 1. 上海 1. 广州 1. 深圳 或者 1. 北京 2. 上海 3. 广州 4. 深圳 北京 上海 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:2","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"列表嵌套 - 北京 - 上海 - 广东 1. 广州 2. 深圳 北京 上海 广东 广州 深圳 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:7:3","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"八、表格 姓名|分数|排名 --|:--:|--: 张三|100|1 李四|85|2 王五|60|3 姓名 分数 排名 张三 100 1 李四 85 2 王五 60 3 --，:-- : 左对齐 :--: : 居中 --: : 右对齐 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:8:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"九、代码 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"单行代码 `print(\"Hello World!\")` print(\"Hello World!\") ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:1","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"多行代码 \\```cpp #include\u003ciostream\u003e int main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } \\``` #include\u003ciostream\u003eint main() { std::cout \u003c\u003c \"Hello World!\" \u003c\u003c std::endl; return 0; } ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:9:2","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"十、流程图 \\```flow st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop \\``` st=\u003estart: 开始 op=\u003eoperation: My Operation cond=\u003econdition: Yes or No? e=\u003eend st-\u003eop-\u003econd cond(yes)-\u003ee cond(no)-\u003eop ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:10:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"十一、LaTeX公式 ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:0","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"行内公式 $ E=mc^2 $ $ E=mc^2 $ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:1","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":null,"content":"多行公式 $$ \\sum_{i=1}^n a_i=0 $$ $$ f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ $$ \\sum_{i=1}^n a_i=0 $$ $$ f(x_1,x_2,\\ldots,x_n) = x_1^2 + x_2^2 + \\cdots + x_n^2 $$ ","date":"2021-02-04","objectID":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:11:2","tags":null,"title":"Markdown 基本语法","uri":"/posts/markdown-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"}]