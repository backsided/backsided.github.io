<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>C++ STL 教程 - Backsided's World</title><meta name=Description content="这是Backsided的博客"><meta property="og:title" content="C++ STL 教程"><meta property="og:description" content="标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈等。"><meta property="og:type" content="article"><meta property="og:url" content="https://backsided.github.io/posts/c++-stl-%E6%95%99%E7%A8%8B/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-06T19:38:27+08:00"><meta property="article:modified_time" content="2021-02-06T19:38:27+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ STL 教程"><meta name=twitter:description content="标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈等。"><meta name=application-name content="Backsided's World"><meta name=apple-mobile-web-app-title content="Backsided's World"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://backsided.github.io/posts/c++-stl-%E6%95%99%E7%A8%8B/><link rel=prev href=https://backsided.github.io/posts/python-%E6%95%99%E7%A8%8B/><link rel=next href=https://backsided.github.io/posts/java-se-%E6%95%99%E7%A8%8B/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"C++ STL 教程","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/backsided.github.io\/posts\/c\u002b\u002b-stl-%E6%95%99%E7%A8%8B\/"},"genre":"posts","wordcount":4523,"url":"https:\/\/backsided.github.io\/posts\/c\u002b\u002b-stl-%E6%95%99%E7%A8%8B\/","datePublished":"2021-02-06T19:38:27+08:00","dateModified":"2021-02-06T19:38:27+08:00","publisher":{"@type":"Organization","name":"Backsided"},"author":{"@type":"Person","name":"Backsided"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':''==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:''==='dark')&&document.body.setAttribute('theme','dark')</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Backsided's World">Backsided's World</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>文章 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/categories/>分类 </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Backsided's World">Backsided's World</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><a class=menu-item href=/posts/ title>文章</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/categories/ title>分类</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">C++ STL 教程</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=" author" class=author><i class="fas fa-user-circle fa-fw"></i>Backsided</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-02-06>2021-02-06</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 4523 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 10 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#vector><code>&lt;vector></code></a><ul><li><a href=#vector-1><code>vector</code></a></li><li><a href=#vectorbool><code>vector&lt;bool></code></a></li></ul></li><li><a href=#stack><code>&lt;stack></code></a><ul><li><a href=#21-初始化>2.1 初始化</a></li><li><a href=#22-操作>2.2 操作</a></li></ul></li><li><a href=#list><code>&lt;list></code></a><ul><li><a href=#31-基本操作>3.1 基本操作</a></li><li><a href=#32-特殊操作>3.2 特殊操作</a></li></ul></li><li><a href=#queue>&lt;queue></a><ul><li><a href=#queue-1>queue</a></li><li><a href=#priority_queue>priority_queue</a></li></ul></li><li><a href=#deque>&lt;deque></a><ul><li><a href=#51-初始化>5.1 初始化</a></li><li><a href=#52-修改>5.2 修改</a></li><li><a href=#53-遍历>5.3 遍历</a></li><li><a href=#54-操作>5.4 操作</a></li></ul></li><li><a href=#map><code>&lt;map></code></a><ul><li><a href=#map-1>map</a></li><li><a href=#multimap>multimap</a></li></ul></li><li><a href=#unordered_map>&lt;unordered_map></a><ul><li><a href=#unordered_map-1>unordered_map</a></li><li><a href=#unordered_multimap>unordered_multimap</a></li></ul></li><li><a href=#set>&lt;set></a><ul><li><a href=#set-1>set</a></li><li><a href=#multiset>multiset</a></li></ul></li><li><a href=#unordered_set>&lt;unordered_set></a><ul><li><a href=#unordered_set-1>unordered_set</a></li><li><a href=#unordered_multiset>unordered_multiset</a></li></ul></li><li><a href=#bitset>&lt;bitset></a><ul><li><a href=#初始化-1>初始化</a></li><li><a href=#位运算>位运算</a></li><li><a href=#操作-1>操作</a></li></ul></li><li><a href=#algorithm>&lt;algorithm></a><ul><li><a href=#sort>sort</a></li><li><a href=#reverse>reverse</a></li><li><a href=#lower_bound>lower_bound</a></li><li><a href=#upper_bound>upper_bound</a></li><li><a href=#search>search</a></li></ul></li><li><a href=#tuple><code>&lt;tuple></code></a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div></div><div class=content id=content><p>标准模板库（Standard Template Library，STL）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈等。</p><p>C++ 标准模板库的核心包括以下三个组件：</p><ol><li>容器（Containers）：用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，如 deque、list、vector、map、set、bitset 等。</li><li>算法（Algorithms）：对容器执行各种操作，包括初始化、排序、搜索和翻转等。</li><li>迭代器（Iterators）：遍历容器。</li></ol><h2 id=vector><code>&lt;vector></code></h2><p><code>vector</code>是一个动态数组，需要<code>#include &lt;vector></code>。</p><ul><li>数组大小动态改变</li><li>可以进行逻辑操作（是否相等、比较大小）</li></ul><h3 id=vector-1><code>vector</code></h3><h4 id=11-初始化>1.1 初始化</h4><ul><li><code>vector()</code> 初始化为空</li><li><code>explicit vector(size_type n)</code> 初始化为 n 个 0</li><li><code>vector(size_type n, const value_type& val)</code> 初始化为 n 个 val</li><li><code>vector(InputIterator first, InputIterator last)</code> 初始化为数组或迭代器 [first, last) 区间内的元素</li><li><code>vector(const vector& x)</code> 复制 vector 中的元素</li><li><code>vector(initializer_list&lt;value_type> il)</code> 复制指定列表中的元素</li><li><code>vector& operator=(const vector& x)</code> 复制 vector 中的元素</li><li><code>vector& operator=(initializer_list&lt;value_type> il)</code> 复制指定列表中的元素</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v1;                              <span style=color:#75715e>// {}
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v2 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};                  <span style=color:#75715e>// {1, 2, 3}
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v3({<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>});                   <span style=color:#75715e>// {1, 2, 3}
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v4 <span style=color:#f92672>=</span> v3;                         <span style=color:#75715e>// {1, 2, 3}
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v5(v3);                          <span style=color:#75715e>// {1, 2, 3}
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v6(<span style=color:#ae81ff>3</span>);                           <span style=color:#75715e>// {0, 0, 0}
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v7(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>2</span>);                        <span style=color:#75715e>// {2, 2, 2}
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v8(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);                <span style=color:#75715e>// {1}
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v9(v4.begin(), v4.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>);  <span style=color:#75715e>// {1, 2}
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> v10(<span style=color:#ae81ff>2</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#ae81ff>3</span>));  <span style=color:#75715e>// {{0, 0, 0}, {0, 0, 0}}
</span></code></pre></div><blockquote><p>类型任意，长度可以是变量</p></blockquote><h4 id=12-添加>1.2 添加</h4><ul><li><code>void push_back(const value_type& val)</code> 在末尾添加元素</li><li><code>void emplace_back(Args&&... args)</code> 在末尾构造并插入元素</li><li><code>iterator emplace(const_iterator position, Args&&... args)</code> 在指定位置构造并插入元素</li><li><code>iterator insert(const_iterator position, const value_type& val)</code> 在指定位置插入元素</li><li><code>iterator insert(const_iterator position, size_type n, const value_type& val)</code> 在指定位置插入 n 个 val</li><li><code>iterator insert(const_iterator position, InputIterator first, InputIterator last)</code> 在指定位置插入数组或迭代器 [first, last) 区间内的元素</li><li><code>iterator insert(const_iterator position, initializer_list&lt;value_type> il)</code> 在指定位置插入指定列表中的元素</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>vector<span style=color:#f92672>&lt;</span>pair<span style=color:#f92672>&lt;</span>string, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> v;
v.push_back(make_pair(<span style=color:#e6db74>&#34;Mike&#34;</span>, <span style=color:#ae81ff>1</span>));
v.emplace_back(<span style=color:#e6db74>&#34;John&#34;</span>, <span style=color:#ae81ff>2</span>);  <span style=color:#75715e>// 隐式地构造了 pair 并插入末尾
</span></code></pre></div><h4 id=13-删除>1.3 删除</h4><ul><li><code>void pop_back()</code> 删除最后一个元素</li><li><code>iterator erase(const_iterator position)</code> 删除指定位置的元素</li><li><code>iterator erase(const_iterator first, const_iterator last)</code> 删除迭代器 [first, last) 区间内的元素</li><li><code>void clear() noexcept</code> 清空</li></ul><h4 id=14-容量>1.4 容量</h4><ul><li><code>bool empty() const</code> 判断容器是否为空</li><li><code>size_type size() const</code> 返回元素个数</li><li><code>size_type capacity() const noexcept</code> 返回已分配存储容量的大小</li><li><code>void resize(size_type n)</code> 改变大小，变小截断，变大补 0</li><li><code>void resize(size_type n, const value_type& val)</code> 改变大小，变小截断，变大补 val</li></ul><h4 id=15-其他操作>1.5 其他操作</h4><ul><li><code>void assign(size_type n, const value_type& val)</code> 赋值为 n 个 val</li><li><code>void assign(InputIterator first, InputIterator last)</code> 赋值为数组或迭代器 [first, last) 区间内的元素</li><li><code>void assign(initializer_list&lt;value_type> il)</code> 赋值为指定列表中的元素</li><li><code>void swap(vector& x)</code> 交换两个 vector</li></ul><h4 id=16-遍历>1.6 遍历</h4><ul><li><code>reference operator[](size_type n)</code> 返回位置为 n 的元素的引用，越界发生未知错误（不推荐）</li><li><code>reference at(size_type n)</code> 返回位置为 n 的元素的引用，越界抛出 out_of_range 异常（推荐）</li><li><code>reference front()</code> 返回第一个元素的引用</li><li><code>reference back()</code> 返回最后一个元素的引用</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> v.begin(); it <span style=color:#f92672>!=</span> v.end(); it<span style=color:#f92672>++</span>)   {<span style=color:#f92672>*</span>it;}  <span style=color:#75715e>// 正向遍历，有迭代器
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> v.rbegin(); it <span style=color:#f92672>!=</span> v.rend(); it<span style=color:#f92672>++</span>) {<span style=color:#f92672>*</span>it;}  <span style=color:#75715e>// 反向遍历，有迭代器
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> e : v) {e;}                                    <span style=color:#75715e>// 正向遍历，无索引
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> e : v)  {e;}                                    <span style=color:#75715e>// 正向遍历，无索引，不改变原数据
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> v.size(); i<span style=color:#f92672>++</span>)      {v.at(i);}       <span style=color:#75715e>// 正向遍历，有索引
</span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> v.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>; i<span style=color:#f92672>--</span>) {v.at(i);}       <span style=color:#75715e>// 反向遍历，有索引
</span></code></pre></div><h3 id=vectorbool><code>vector&lt;bool></code></h3><p>基本操作同 <a href=#vector-1 rel>vector</a>。</p><p>特殊操作：</p><ul><li><code>void flip() noexcept</code> 所有位都翻转</li><li><code>static void swap(reference ref1, reference ref2) noexcept</code> 交换两个位置的值</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>bool</span><span style=color:#f92672>&gt;</span> mask;
mask.push_back(true);
mask.push_back(false);        <span style=color:#75715e>// {1 0}
</span><span style=color:#75715e></span>mask.flip();                  <span style=color:#75715e>// {0 1}
</span><span style=color:#75715e></span>mask.swap(mask[<span style=color:#ae81ff>0</span>], mask[<span style=color:#ae81ff>1</span>]);  <span style=color:#75715e>// {1 0}
</span></code></pre></div><h2 id=stack><code>&lt;stack></code></h2><p><code>stack</code>是一个栈，需要<code>#include &lt;stack></code>。</p><ul><li>后进先出（LIFO）</li></ul><h3 id=21-初始化>2.1 初始化</h3><ul><li>默认底层容器是 <a href=#deque rel>deque</a></li><li>可以显式设置底层容器为 <a href=#vector-1 rel>vector</a></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st1;
stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st2(st1);
stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st3({<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>});       <span style=color:#75715e>// st3.top() == 3
</span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>);
stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st4(dq);              <span style=color:#75715e>// 默认底层容器是 deque
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v({<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>});
stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> st5(v);  <span style=color:#75715e>// 设置底层容器为 vector
</span></code></pre></div><h3 id=22-操作>2.2 操作</h3><ul><li><code>void push(const value_type& val)</code> 栈顶添加元素</li><li><code>void emplace(Args&&... args)</code> 栈顶添加元素</li><li><code>void pop()</code> 栈顶弹出元素</li><li><code>reference& top()</code> 返回栈顶元素</li><li><code>bool empty() const</code> 判断栈是否为空</li><li><code>size_type size() const</code> 返回元素个数</li><li><code>void swap(stack& x) noexcept</code> 交换两个栈</li></ul><h2 id=list><code>&lt;list></code></h2><p><code>list</code>是一个双向链表，需要<code>#include &lt;list></code>。</p><ul><li>无法按索引访问元素</li><li>插入删除元素效率高</li></ul><h3 id=31-基本操作>3.1 基本操作</h3><p>基本操作同 <a href=#vector-1 rel>vector</a>。</p><h3 id=32-特殊操作>3.2 特殊操作</h3><p>添加：</p><ul><li><code>void push_front(const value_type& val)</code> 在开头插入元素</li><li><code>void emplace_front(Args&&... args)</code> 在开头构造并插入元素</li><li><code>void splice(const_iterator position, list& x)</code> 将 x 中的元素转移到指定位置</li><li><code>void splice(const_iterator position, list& x, const_iterator i)</code> 将 x 中的位置为 i 元素转移到指定位置</li><li><code>void splice(const_iterator position, list& x, const_iterator first, const_iterator last)</code> 将 x 中的 [first, last) 区间内的元素转移到指定位置</li><li><code>void merge(list& x)</code></li><li><code>void merge(list& x, Compare comp)</code></li></ul><p>删除：</p><ul><li><code>void pop_front()</code> 删除第一个元素</li><li><code>void remove(const value_type& val)</code> 删除值为 val 的所有元素</li><li><code>void remove_if(Predicate pred)</code> 删除满足自定义一元函数的元素</li><li><code>void unique()</code> 删除连续重复元素，只保留一个</li><li><code>void unique(BinaryPredicate binary_pred)</code> 删除满足自定义二元函数的元素</li></ul><p>其他：</p><ul><li><code>void sort()</code> 按升序排序</li><li><code>void sort(Compare comp)</code> 按自定义二元函数排序</li><li><code>void reverse() noexcept</code> 逆序</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>list<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> l <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>};
l.unique();  <span style=color:#75715e>// {1, 2, 1, 2}
</span></code></pre></div><h2 id=queue>&lt;queue></h2><p><code>queue</code>是一个单向队列容器，需要<code>#include &lt;list></code>。</p><h3 id=queue-1>queue</h3><ul><li>先进先出（FIFO）</li><li>队尾添加，队首删除</li></ul><h4 id=411-初始化>4.1.1 初始化</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q1;                            <span style=color:#75715e>// 空 queue
</span><span style=color:#75715e></span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q2(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>2</span>);                      <span style=color:#75715e>// 大小为 5 的 queue，值均为 2
</span><span style=color:#75715e></span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q3(q2);                        <span style=color:#75715e>// 复制 queue
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q4(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);              <span style=color:#75715e>// 复制数组 [first, last) 区间内的元素
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q5(v.begin(), v.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);  <span style=color:#75715e>// 复制迭代器 [first, last) 区间内的元素
</span><span style=color:#75715e></span>queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q6(v);                         <span style=color:#75715e>// 复制 vector
</span></code></pre></div><h4 id=412-操作>4.1.2 操作</h4><ul><li><code>void push(const value_type& val)</code> 队尾添加元素</li><li><code>void emplace(Args&&... args)</code> 队尾添加元素</li><li><code>void pop()</code> 删除队首元素</li><li><code>const_reference& front() const</code> 返回队首元素</li><li><code>const_reference& back() const</code> 返回队尾元素</li><li><code>size_type size() const</code> 返回大小</li><li><code>bool empty() const</code> 是否为空</li><li><code>void swap(queue& x) noexcept</code> 交换</li></ul><h3 id=priority_queue>priority_queue</h3><ul><li>优先队列（堆）</li><li>默认最大优先队列（最大堆）</li><li>自动调整顺序使队首（堆顶）元素最大</li></ul><h4 id=421-初始化>4.2.1 初始化</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pq1;                             <span style=color:#75715e>// 空 priority_queue
</span><span style=color:#75715e></span>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pq2(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>2</span>);                       <span style=color:#75715e>// 大小为 5 的 priority_queue，值均为 2
</span><span style=color:#75715e></span>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pq3(pq2);                        <span style=color:#75715e>// 复制 priority_queue
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pq4(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);               <span style=color:#75715e>// 复制数组 [first, last) 区间内的元素
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pq5(v.begin(), v.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);   <span style=color:#75715e>// 复制迭代器 [first, last) 区间内的元素
</span><span style=color:#75715e></span>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> pq6(v);                          <span style=color:#75715e>// 复制 vector
</span><span style=color:#75715e></span>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, less<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> pq7;     <span style=color:#75715e>// 最大优先队列（最大堆）
</span><span style=color:#75715e></span>priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>, greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&gt;</span> pq8;  <span style=color:#75715e>// 最小优先队列（最小堆）
</span></code></pre></div><h4 id=422-操作>4.2.2 操作</h4><ul><li><code>void push(const value_type& val)</code> 添加元素</li><li><code>void emplace(Args&&... args)</code> 添加元素</li><li><code>void pop()</code> 删除队首（堆顶）元素</li><li><code>const_reference top() const</code> 返回队首（堆顶）元素</li><li><code>size_type size() const</code> 返回大小</li><li><code>bool empty() const</code> 是否为空</li><li><code>void swap(priority_queue& x) noexcept</code> 交换</li></ul><h2 id=deque>&lt;deque></h2><p><code>deque</code>是一个双端队列容器，需要<code>#include &lt;deque></code>。</p><h3 id=51-初始化>5.1 初始化</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq1;                                <span style=color:#75715e>// 空 deque
</span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq2(<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>2</span>);                          <span style=color:#75715e>// 大小为 5 的 deque，值均为 2
</span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq3(dq2);                           <span style=color:#75715e>// 复制 deque
</span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq4(dq2.begin(), dq2.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);  <span style=color:#75715e>// 复制迭代器 [first, last) 区间内的元素
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq5(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);                  <span style=color:#75715e>// 复制数组 [first, last) 区间内的元素
</span><span style=color:#75715e></span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq6(v.begin(), v.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);      <span style=color:#75715e>// 复制迭代器 [first, last) 区间内的元素
</span><span style=color:#75715e></span>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq7 <span style=color:#f92672>=</span> dq6;
deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq8 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
</code></pre></div><h3 id=52-修改>5.2 修改</h3><ul><li><code>void push_back(const value_type& val)</code> 队尾添加元素</li><li><code>void push_front(const value_type& val)</code> 队首添加元素</li><li><code>void emplace_back(Args&&... args)</code> 队尾添加元素</li><li><code>void emplace_front(Args&&... args)</code> 队首添加元素</li><li><code>iterator emplace(const_iterator position, Args&&... args)</code> 迭代器指定位置前面添加元素</li><li><code>iterator insert(const_iterator position, const value_type& val)</code> 迭代器指定位置前面添加元素</li><li><code>iterator insert(const_iterator position, size_type n, const value_type& val)</code> 迭代器指定位置前面添加 n 个相同元素</li><li><code>iterator insert(const_iterator position, InputIterator first, InputIterator last)</code> 迭代器指定位置前面添加 [first, last) 区间内元素</li><li><code>iterator insert(const_iterator position, initializer_list&lt;value_type> il)</code></li><li><code>void pop_back()</code> 删除队尾</li><li><code>void pop_front()</code> 删除队首</li><li><code>iterator erase(iterator position)</code> 删除迭代器指向元素</li><li><code>iterator erase(const_iterator first, const_iterator last)</code> 删除 [first, last) 区间内元素</li><li><code>void clear() noexcept</code> 清空</li></ul><h3 id=53-遍历>5.3 遍历</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>deque<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> dq;
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> dq.begin(); it <span style=color:#f92672>!=</span> dq.end(); it<span style=color:#f92672>++</span>) {<span style=color:#f92672>*</span>it;}
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> dq.rbegin(); it <span style=color:#f92672>!=</span> dq.rend(); it<span style=color:#f92672>++</span>) {<span style=color:#f92672>*</span>it;}
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> e : dq) {e;}
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> e : dq) {e;}
</code></pre></div><h3 id=54-操作>5.4 操作</h3><ul><li><code>size_type size() const noexcept</code> 返回大小</li><li><code>void resize(size_type n)</code> 调整大小为 n，调大补 0，调小末尾截断</li><li><code>void resize(size_type n, const value_type& val)</code> 调整大小为 n，调大补 val，调小末尾截断</li><li><code>bool empty() const noexcept</code> 判断是否为空</li><li><code>reference operator[](size_type n)</code> 访问指定位置元素，越界报错</li><li><code>reference at(size_type n)</code> 访问指定位置元素，越界抛出 out_of_range 异常</li><li><code>const_reference back() const</code> 返回队尾元素</li><li><code>const_reference front() const</code> 返回队首元素</li></ul><h2 id=map><code>&lt;map></code></h2><p><code>map</code>是一个有序键值对容器，每个元素由关键字（key）和该关键字对应的值（value）组合而成。需要<code>#include &lt;map></code>。</p><h3 id=map-1>map</h3><ul><li><code>key</code>唯一且无法修改</li><li>默认按<code>key</code>升序排列</li><li>底层二叉搜索树实现，速度比<code>unordered_map</code>慢</li></ul><h4 id=61-初始化>6.1 初始化</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m1;
map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m2(m1);
map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m3(m1.begin(), m1.end());
map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span>, less<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> m4;     <span style=color:#75715e>// 按 key 升序排列，相当于 map&lt;char, int&gt;
</span><span style=color:#75715e></span>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span>, greater<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;&gt;</span> m5;  <span style=color:#75715e>// 按 key 降序排列
</span></code></pre></div><h4 id=62-添加>6.2 添加</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m1, m2;
m1[<span style=color:#e6db74>&#39;a&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
m1.insert(make_pair(<span style=color:#e6db74>&#39;b&#39;</span>, <span style=color:#ae81ff>2</span>));
m1.insert(pair<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#39;c&#39;</span>, <span style=color:#ae81ff>3</span>));
m1.emplace(<span style=color:#e6db74>&#39;d&#39;</span>, <span style=color:#ae81ff>4</span>);
m2.insert(m1.begin(), m1.find(<span style=color:#e6db74>&#39;c&#39;</span>));
</code></pre></div><h4 id=63-删除>6.3 删除</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m;
m[<span style=color:#e6db74>&#39;a&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
m[<span style=color:#e6db74>&#39;b&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
m[<span style=color:#e6db74>&#39;c&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
m.erase(m.find(<span style=color:#e6db74>&#39;c&#39;</span>));
m.erase(<span style=color:#e6db74>&#39;a&#39;</span>);
m.erase(m.begin(), m.end());
m.clear();
</code></pre></div><h4 id=64-遍历>6.4 遍历</h4><ul><li><code>mapped_type& operator[](const key_type& k)</code></li><li><code>mapped_type& at(const key_type& k)</code></li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> m.begin();  it <span style=color:#f92672>!=</span> m.end();  it<span style=color:#f92672>++</span>) { it<span style=color:#f92672>-&gt;</span>first; it<span style=color:#f92672>-&gt;</span>second; }
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> m.rbegin(); it <span style=color:#f92672>!=</span> m.rend(); it<span style=color:#f92672>++</span>) { it<span style=color:#f92672>-&gt;</span>first; it<span style=color:#f92672>-&gt;</span>second; }
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> <span style=color:#f92672>&amp;</span>p : m) { p.first; p.second; }
</code></pre></div><h4 id=65-其他操作>6.5 其他操作</h4><ul><li><code>size_type size() const noexcept</code> 返回元素个数</li><li><code>bool empty() const noexcept</code> 判断是否为空</li><li><code>void swap(map& x)</code> 交换两个 map</li><li><code>iterator find(const key_type& k)</code> 查找 key 值为 k 的元素，未找到返回 map::end()</li><li><code>size_type count(const key_type& k) const</code> 返回 key 值为 k 的元素的数量，由于 key 唯一，则存在返回 1，不存在返回 0</li><li><code>iterator lower_bound(const key_type& k)</code> 返回指向第一个 key 大于等于 k 的元素的迭代器</li><li><code>iterator upper_bound(const key_type& k)</code> 返回指向第一个 key 大于 k 的元素的迭代器</li><li><code>pair&lt;iterator, iterator> equal_range(const key_type& k)</code> 返回指向 key 等于 k 的所有元素的范围的边界元素的迭代器 [first, second)</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> m;
m[<span style=color:#e6db74>&#39;a&#39;</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
m.find(<span style=color:#e6db74>&#39;b&#39;</span>);   <span style=color:#75715e>// m.end()
</span><span style=color:#75715e></span>m.count(<span style=color:#e6db74>&#39;a&#39;</span>);  <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>m.count(<span style=color:#e6db74>&#39;b&#39;</span>);  <span style=color:#75715e>// 0
</span></code></pre></div><h4 id=66-排序>6.6 排序</h4><blockquote><p><code>map</code>没有随机迭代器，只有顺序迭代器，所以不能用<code>sort</code></p></blockquote><h5 id=661-按-key-排序>6.6.1 按 key 排序</h5><p><strong>key 升序，value 随机</strong></p><p>默认情况，<code>map&lt;int, char></code>，相当于<code>map&lt;int, char, less&lt;int>></code>。</p><p>当 key 为自定义类时：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {  <span style=color:#75715e>// 自定义类
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> one, two;
} Grade;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cmp</span> {      <span style=color:#75715e>// 自定义比较类
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> Grade<span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>const</span> Grade<span style=color:#f92672>&amp;</span> b) <span style=color:#66d9ef>const</span> {
        <span style=color:#66d9ef>if</span> (a.one <span style=color:#f92672>!=</span> b.one) <span style=color:#66d9ef>return</span> a.one <span style=color:#f92672>&lt;</span> b.one;
        <span style=color:#66d9ef>return</span> a.two <span style=color:#f92672>&lt;</span> b.two;
    }
};

map<span style=color:#f92672>&lt;</span>Grade, <span style=color:#66d9ef>int</span>, Cmp<span style=color:#f92672>&gt;</span> m;
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> {  <span style=color:#75715e>// 自定义类
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> one, two;
} Grade;

<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Cmp</span> {      <span style=color:#75715e>// 自定义比较类
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> Grade<span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>const</span> Grade<span style=color:#f92672>&amp;</span> b) <span style=color:#66d9ef>const</span> {
        <span style=color:#66d9ef>if</span> (a.one <span style=color:#f92672>!=</span> b.one) <span style=color:#66d9ef>return</span> a.one <span style=color:#f92672>&lt;</span> b.one;
        <span style=color:#66d9ef>return</span> a.two <span style=color:#f92672>&lt;</span> b.two;
    }
};

map<span style=color:#f92672>&lt;</span>Grade, <span style=color:#66d9ef>int</span>, Cmp<span style=color:#f92672>&gt;</span> m;
</code></pre></div><p><strong>key 降序，value 随机</strong></p><p><code>map&lt;int, char, greater&lt;int>></code></p><h5 id=662-按-value-排序>6.6.2 按 value 排序</h5><p><strong>key 降序，value 随机</strong></p><p><strong>key 降序，value 随机</strong></p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>
</code></pre></div><h3 id=multimap>multimap</h3><ul><li><code>key</code>允许重复</li><li>默认按<code>key</code>升序排列</li><li>底层二叉搜索树实现，速度比<code>unordered_multimap</code>慢</li></ul><p>基本使用方法同 <a href=#map-1 rel>map</a>。</p><h2 id=unordered_map>&lt;unordered_map></h2><h3 id=unordered_map-1>unordered_map</h3><ul><li><code>key</code>唯一且不能修改，可以添加或删除</li><li>无序</li><li>速度比<code>map</code>快</li></ul><h3 id=unordered_multimap>unordered_multimap</h3><h2 id=set>&lt;set></h2><p><code>set</code>是一个有序集合容器。需要<code>#include &lt;set></code>。</p><h3 id=set-1>set</h3><ul><li>元素唯一</li><li>元素默认升序</li><li>底层二叉排序树实现，速度比<code>unordered_set</code>慢</li></ul><h4 id=初始化>初始化</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s1;                              <span style=color:#75715e>// {}
</span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s2 <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};                  <span style=color:#75715e>// { 1 2 3 }
</span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s3 <span style=color:#f92672>=</span> s2;                         <span style=color:#75715e>// { 1 2 3 }
</span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s4({<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>});                   <span style=color:#75715e>// { 1 2 3 }
</span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s5(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>);                <span style=color:#75715e>// { 1 2 3 }
</span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s6(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);                <span style=color:#75715e>// { 1 }
</span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s7(s4);                          <span style=color:#75715e>// { 1 2 3 }
</span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s8(s4.begin(), s4.end());        <span style=color:#75715e>// { 1 2 3 }
</span><span style=color:#75715e></span>set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s9(s4.begin(), s4.begin() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);  <span style=color:#75715e>// { 1 }
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>CompClass</span> {
    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>operator</span>() (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> left, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> right) <span style=color:#66d9ef>const</span> {
        <span style=color:#66d9ef>return</span> left <span style=color:#f92672>&lt;</span> right;
    }
};
set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, CompClass<span style=color:#f92672>&gt;</span> s10;                  <span style=color:#75715e>// { 1 2 3 }
</span></code></pre></div><h4 id=修改>修改</h4><ul><li><code>pair&lt;iterator, bool> emplace(Args&&... args)</code> 添加一个元素</li><li><code>pair&lt;iterator, bool> insert(value_type&& val)</code> 添加一个元素</li><li><code>void insert(InputIterator first, InputIterator last)</code> 添加 [first, last) 范围内的元素</li><li><code>void insert(initializer_list&lt;value_type> il)</code> 添加另一个容器的所有元素</li><li><code>iterator erase(const_iterator position)</code> 删除指定位置元素</li><li><code>size_type erase(const value_type& val)</code> 删除指定元素</li><li><code>iterator erase(const_iterator first, const_iterator last)</code> 删除 [first, last) 范围内的元素</li><li><code>void swap(set& x)</code> 交换两个 set</li><li><code>void clear() noexcept</code> 清空</li></ul><h4 id=容量>容量</h4><ul><li><code>bool empty() const noexcept</code> 判断是否为空</li><li><code>size_type size() const noexcept</code> 当前元素个数</li></ul><h4 id=遍历>遍历</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> s.begin(); it <span style=color:#f92672>!=</span> s.end(); it<span style=color:#f92672>++</span>) {<span style=color:#f92672>*</span>it;}
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> it <span style=color:#f92672>=</span> s.rbegin(); it <span style=color:#f92672>!=</span> s.rend(); it<span style=color:#f92672>++</span>) {<span style=color:#f92672>*</span>it;}
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> e : s) {e;}
<span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> e : s) {e;}
</code></pre></div><h4 id=操作>操作</h4><ul><li><code>iterator find(const value_type& val)</code> 查找指定元素，成功返回迭代器，失败返回 end()</li><li><code>size_type count(const value_type& val) const</code> 返回指定元素的个数</li><li><code>iterator lower_bound(const value_type& val)</code> 下界，查找<strong>第1个大于等于</strong>指定元素的位置，成功返回迭代器，失败返回 end()</li><li><code>iterator upper_bound(const value_type& val)</code> 上界，查找<strong>最后一个小于等于</strong>指定元素的位置，成功返回迭代器，失败返回 end()</li><li><code>pair&lt;iterator, iterator> equal_range(const value_type& val)</code> 返回 set 中与指定元素相等的一个范围 [first, second)</li></ul><h3 id=multiset>multiset</h3><ul><li>允许重复元素</li><li>元素默认升序</li><li>速度比<code>unordered_set</code>慢</li><li>使用方法同<code>set</code></li></ul><h2 id=unordered_set>&lt;unordered_set></h2><p><code>unordered_set</code>是一个无序集合容器。需要<code>#include &lt;unordered_set></code>。</p><h3 id=unordered_set-1>unordered_set</h3><ul><li>元素唯一</li><li>无序</li><li>底层哈希表实现，速度比<code>set</code>快</li><li>使用方法同<code>set</code></li></ul><h3 id=unordered_multiset>unordered_multiset</h3><ul><li>允许重复元素</li><li>无序</li><li>速度比<code>multiset</code>快</li><li>使用方法同<code>set</code></li></ul><h2 id=bitset>&lt;bitset></h2><p><code>bitset</code>模拟一个 bool 数组，每个元素只能是 0 或 1.</p><h3 id=初始化-1>初始化</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>bitset<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span> b1;           <span style=color:#75715e>// 0000
</span><span style=color:#75715e></span>bitset<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span> b2(<span style=color:#e6db74>&#34;100&#34;</span>);    <span style=color:#75715e>// 0100, b2[0] == 0
</span><span style=color:#75715e></span>bitset<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span> b3(<span style=color:#e6db74>&#34;1100&#34;</span>);   <span style=color:#75715e>// 1100
</span><span style=color:#75715e></span>bitset<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span> b4(<span style=color:#e6db74>&#34;11100&#34;</span>);  <span style=color:#75715e>// 1110
</span><span style=color:#75715e></span>bitset<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span> b5(b2);       <span style=color:#75715e>// 0100
</span><span style=color:#75715e></span>string s <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;1010&#34;</span>;
bitset<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span> b6(s);        <span style=color:#75715e>// 1010
</span></code></pre></div><h3 id=位运算>位运算</h3><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>bitset<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>4</span><span style=color:#f92672>&gt;</span> a(<span style=color:#e6db74>&#34;1001&#34;</span>), b(<span style=color:#e6db74>&#34;1010&#34;</span>);
a <span style=color:#f92672>&amp;</span> b;   <span style=color:#75715e>// 1000 AND
</span><span style=color:#75715e></span>a <span style=color:#f92672>|</span> b;   <span style=color:#75715e>// 1011 OR
</span><span style=color:#75715e></span>a <span style=color:#f92672>^</span> b;   <span style=color:#75715e>// 0011 XOR
</span><span style=color:#75715e></span><span style=color:#f92672>~</span>a;      <span style=color:#75715e>// 0110 NOT
</span><span style=color:#75715e></span>a <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 0010 SHL
</span><span style=color:#75715e></span>a <span style=color:#f92672>&gt;&gt;</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 0100 SHR
</span><span style=color:#75715e></span>a <span style=color:#f92672>==</span> b;  <span style=color:#75715e>// false
</span><span style=color:#75715e></span>a <span style=color:#f92672>!=</span> b;  <span style=color:#75715e>// true
</span></code></pre></div><h3 id=操作-1>操作</h3><ul><li><code>reference operator[](size_t pos)</code> 访问指定位置，<strong>0 是最右边一位，即最低位</strong></li><li><code>size_t count() const noexcept</code> 返回 1 的 个数</li><li><code>size_t size() const noexcept</code> 返回长度</li><li><code>bool test(size_t pos) const</code> 判断指定位置是否为 1</li><li><code>bool any() const noexcept</code> 判断是否存在某一位是 1</li><li><code>bool none() const noexcept</code> 判断是否全是 0</li><li><code>bool all() const noexcept</code> 判断是否全是 1</li><li><code>bitset& set() noexcept</code> 全部置为 1</li><li><code>bitset& set(size_t pos, bool val = true)</code> 指定位置置为 1</li><li><code>bitset& reset() noexcept</code> 全部置为 0</li><li><code>bitset& reset(size_t pos)</code> 指定位置置为 0</li><li><code>bitset& flip() noexcept</code> 翻转</li><li><code>bitset& flip(size_t pos)</code> 翻转指定位置</li><li><code>string to_string() const</code> 返回该二进制数的字符串</li><li><code>unsigned long to_ulong() const</code> 返回该 2 进制数对应的整数，类型 unsigned long</li><li><code>unsigned long long to_ullong() const</code> 返回该 2 进制数对应的整数，类型 unsigned long long</li></ul><h2 id=algorithm>&lt;algorithm></h2><h3 id=sort>sort</h3><h4 id=数组排序>数组排序</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>cmp</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) { <span style=color:#66d9ef>return</span> a <span style=color:#f92672>&gt;</span> b; }  <span style=color:#75715e>// 自定义降序比较函数
</span><span style=color:#75715e></span>
<span style=color:#66d9ef>int</span> arr[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>};
sort(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>);             <span style=color:#75715e>// {1, 2, 3}
</span><span style=color:#75715e></span>sort(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>, cmp);        <span style=color:#75715e>// {3, 2, 1}
</span><span style=color:#75715e></span>
vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> v(arr, arr <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>);
sort(v.begin(), v.end());       <span style=color:#75715e>// {1, 2, 3}
</span><span style=color:#75715e></span>sort(v.begin(), v.end(), cmp);  <span style=color:#75715e>// {3, 2, 1}
</span></code></pre></div><h4 id=类结构体排序>类（结构体）排序</h4><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Stu</span> {  <span style=color:#75715e>// 自定义类
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
    <span style=color:#66d9ef>int</span> no;
    <span style=color:#66d9ef>int</span> score;
};

<span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>cmpClass</span>(Stu<span style=color:#f92672>&amp;</span> a, Stu<span style=color:#f92672>&amp;</span> b) {  <span style=color:#75715e>// 自定义类的降序比较函数
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> a.score <span style=color:#f92672>&gt;</span> b.score;
}

Stu stu[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>90</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>100</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>80</span>};  <span style=color:#75715e>// {{1, 90}, {2, 100}, {3, 80}}
</span><span style=color:#75715e></span>sort(stu, stu <span style=color:#f92672>+</span> <span style=color:#ae81ff>3</span>, cmpClass);        <span style=color:#75715e>// {{2, 100}, {1, 90}, {3, 80}}
</span></code></pre></div><h3 id=reverse>reverse</h3><h3 id=lower_bound>lower_bound</h3><h3 id=upper_bound>upper_bound</h3><h3 id=search>search</h3><h2 id=tuple><code>&lt;tuple></code></h2><p><code>tuple</code>将不同类型的许多元素打包成一个对象，便于访问，（就像定义了一个只有属性的类，并且属性只定义了类型，未定义名字）。需要<code>#include &lt;tuple></code>。</p><ul><li>元素类型任意</li><li>元素数量任意</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp>tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, string<span style=color:#f92672>&gt;</span> t1;
tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, string<span style=color:#f92672>&gt;</span> t2{t1};
tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, string<span style=color:#f92672>&gt;</span> t3(t2);
tuple<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, string<span style=color:#f92672>&gt;</span> t4{<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;one&#34;</span>};

get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span>(t4);       <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>get<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span>(t4);       <span style=color:#75715e>// one
</span><span style=color:#75715e></span>get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(t4);     <span style=color:#75715e>// 1
</span><span style=color:#75715e></span>get<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>(t4);  <span style=color:#75715e>// one
</span><span style=color:#75715e></span>
make_tuple(<span style=color:#ae81ff>2</span>, string(<span style=color:#e6db74>&#34;two&#34;</span>));

</code></pre></div><h2 id=参考资料>参考资料</h2><ol><li><a href=https://www.cplusplus.com/reference/ target=_blank rel="noopener noreffer">Standard C++ Library Reference - cplusplus.com</a></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-02-06</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/python-%E6%95%99%E7%A8%8B/ class=prev rel=prev title="Python 教程"><i class="fas fa-angle-left fa-fw"></i>Python 教程</a>
<a href=/posts/java-se-%E6%95%99%E7%A8%8B/ class=next rel=next title="Java SE 教程">Java SE 教程<i class="fas fa-angle-right fa-fw"></i></a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line>由 <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i>LoveIt</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>Backsided</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>